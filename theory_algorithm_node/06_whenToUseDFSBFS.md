# 06_DFS, BFS 사용 구분

시간복잡도는 똑같구... 메모리를 얼마나 사용하냐는 구조에 달림

## BFS

- 일단 끝까지 갈 수 있는 끝단계까지 쭉 갔다가 다시 한단계씩만 뒤로 돌아와 다음 경우의 수를 찾는다
- depth가 같은 모든 경우의 수를 추적
- 공간복잡도가 매우 커질 수 있음
- 하나의 노드가 계속 연결되어있는 치우처진 트리일 경우, BFS와 거의 같은 공간을 잡아먹긴하지만 왠만한 경우 queue에 인접한 노드들을 거의 다 넣으므로 DFS보다 공간을 많이 잡아먹는다
- **최단 문제의 경우** BFS가 정석이다. 다만 말했듯이 매 단계마다 가능한 경우의 수를 모두 큐에 저장해야 하므로 메모리가 초과될 수 있으니 
- 현재 도달한 상태가 최단으로 도달했다는 것이 보장되어 있다(depth를 일정하게 유지할 수 있으니)
- 우리가 찾을 정답의 단계가 정해져있거나 일반적으로 깊은 단계, 일정한 단계에 있는 문제라면 DFS가 유리하다.

## DFS

- 한 단계에 갈 수 있는 모든 경우의 수를 다 돌리고 그 다음 단계로 넘어감
- 한번에 끝단계를 간 후 결과를 보고나면 메모리를 반환할 수 있다
- 순회시 오더 방법에 따라서 좀 다르게된다 (inorder,postorder,preorder)
- 가장 하단까지 갔다가 다시 순회할때 메모리를 그 path에서만 사용하므로 메모리는 좀 덜먹는다
- 특정 단계까지 내려가야 하고(단계를 모두 완성했을 때라거나), 그 중 최적의 경우를 찾는다고 하면 백트랙킹을 이용해 가지치기가 되는 DFS로 접근하는게 좋다
- 유의해야할것은 단계가 끝나지 않는 순환의 문제가 생길 수 있고, 현재 찾은 정답이 최단이라고 확정지을 수 없으므로 계속 나머지 경우의 수를 세주어야 한다