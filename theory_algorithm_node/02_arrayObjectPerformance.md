# 02_JS 배열과 객체 연산 비용

## 1 - 객체

### 빅오

대체로 빠르다 => 순서가 상관이 없어서

- insertion : O(1) - 순서가 상관이 없음
- removal : O(1) - 순서가 상관이 없음
- searching : O(N) - 키를 찾는게 아니고(그건 상수시간) 키가 많아지면 순회하면서 찾아야되는데 그게 선형시간
- access : O(1)
- Object.keys : O(N) : 아이템이 커질수록 수행시간도 커지기 때문에
- Object.values: O(N)
- Object.entries: O(N)
- Object.hasOwnProperty: O(1) : 바로 찾아보면 되므로

## 2 - 배열

순서가 상관이 있음  
다른 배열을(객체로) 만들어서 써도 됨. 자료구조 중에 하나라고 생각하셈  
수정 성능을 생각하면 링크드 리스트가 더 낫고(리인덱싱이 필요 없어서)..그런거  

### 빅오

- access : 인덱스로의 접근은 상수시간(O(1)), 배열이 얼마나 긴지는 상관이 업슴
- searching : O(N)
- remove/insert : it depends!
  - 뭔가 넣어줄때 모든 elem 리인덱싱 - 대충 O(n)
  - 근데 어떤 지점에 넣어줄지, 혹은 제외할지에 따라서 달라짐. 인덱싱이 바뀌는 범위가 다르니깐.
  - 일반적으로 말할 수 있는 것은 맨 앞을 수정하면(shift, unshift) 리인덱싱이 맥시멈으로 이루어져야 하고, 끝을 수정하면(push, pop) 리인덱싱이 미니멈으로 이루어지기 때문에 뒤가 더 낫다. splice는 그때그때 다르겠구먼
- push : 상수시간
- pop : 상수시간
- shift : 선형시간(리인덱싱)
- unshift: 선형시간(리인덱싱)
- concat : 선형시간 => 두개의 배열을 리인덱싱해서 새로운 배열로 리턴 O(n+m)
- slice - 얕은 복사본 잘라서 반환 : 선형시간
- splice - 해당 인덱싱에서 수정 : 선형시간 => versertile, 리인덱싱 할것들이 그때그때 다르게 됨 
- sort : O(nlogn) => 대충 이야기하면 데이터를 순회하는데 n, 그걸 logn번 하게됨
- forEach/map/filter/reduce : 선형시간