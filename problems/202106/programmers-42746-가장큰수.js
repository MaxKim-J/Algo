function solution(N) {
  // 여기서 정렬 콜백 : 자릿수 문자열을 높게 만들 수 있는 순서대로 오름차순 정렬
  const answer = N.map(c=> c + '').
          sort((a,b) => (b+a) - (a+b)).join('');
  return answer[0] === '0' ? '0' : answer;
}

//? 아직 js sort를 제대로 이해하고 있지 못하다...

/*
[3, 30, 34, 5, 9]	
비교쌍 순서 (30,3) => (34,30) => (34,30) => (34,3) => (5,3) => (5,34) => (9,3) => (9,34) => (9,5)
그냥 앞에 두개 a,b로 만들어서 이해해보면

sort((a,b) => {
  console.log(a,b)
  return (b+a) - (a+b)
})

1)
a는 '3', b는 '30'
b+a는 303이고 a+b는 330인데, 둘은 문자열임
문자열이어도 산술 연산자를 사용하면 정수형으로 바뀌어서 결과가 나옴
(b+a) - (a+b)는 -27인데, 음수를 리턴했기 때문에 a가 b에 앞에 오게됨('3'이 '30'의 앞에 옴)

2)
a는 '5', b는 '9'
b+a 95, a+b 59
(b+a) - (a+b)는 양수를 리턴하기 때문에 b가 a의 앞에 오게됨('9'가 '5'의 앞에 옴)

저런식으로 정렬하고 싶은 배열의 앞뒤 요소를 정렬한다고 했을 때
두개를 합쳐 문자열로 두가지 방식으로 만든 후, *앞에 왔을 때 더 큰 문자열을 만드는 수*가 앞에 오게끔 순서대로 정렬이 됨

요소의 관계를 설정해 정렬을 하는 방식이라는 것,,,
근데 실제로 비교하는 방식을 console.log 찍어서 보면 당연하지만 모든 요소쌍을 일일히 비교하지는 않는다. 
뭔가 최적화된 알고리즘같은게 있는듯. 어쨋든 nlogn은 보장한다.
*/
