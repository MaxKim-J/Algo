# 시간복잡도가 최대 백만이므로 O(N)으로 해결해야 함 => 모든 경우의 수
# * 한번 계산한 값을 다시는 구하지 않는다
# 동적 프로그래밍 문제를 풀기 위해서는 점화식을 세워야 함
# 수열 길이가 i일때 경우의 수가 D(i)라면
# 길이가 i인 수열을 형성하는 방법은 일단 뒤에 1이나 00을 붙이는 경우임
# D(i) = D(i-1) + D(i-2) => 피보나치 수열임
#! 순회 혹은 경우의 수 문제를 자료형을 선형시간안에 순회해서 값을 내야할 때
#! 재귀 : 여러번 계산했던 값을 또 계산하게 되서 연산이 늘어남
#! 그래프 순회 : 경로나 값을 구할때는 그 값을 보존해야할 경우 괜찮은데, 경우의 수를 구할
#! 경우에는 DP를 사용해서 더하는 식으로만 움직여도 연산이 많이 줄듯
# * 점화식만 잘 세우면 코드 길이는 매우 짧다

n = int(input())

dp = [0] * 10000001
dp[1] = 1
dp[2] = 2

for i in range(3, n+1):
    dp[i] = (dp[i-2] + dp[i-1]) % 15746

print(dp[n])
