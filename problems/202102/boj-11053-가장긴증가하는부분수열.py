
# ? 이게 그래프탐색으로 푸는 부분수열 문제랑 다른점이 뭐지? => '증가하는' 부분수열 이라는거
# ? 증가하는 뒷 값중 하나 픽해서 순회 계속하는 방법으로 푸는것보다 나은점이 뭐지? => Length를 기록하기엔 더 쉬운듯
# 조금더 정답 지향적으로 문제를 풀수는 있겠다 => 이거 스터디할때 한번 탐구해보기
# * D[i] = array[i]를 마지막 원소로 가지는 부분수열의 최대 길이
# *  점화식 : D[i] = max(D[i], D[j]+1) if array[j] < array[i]

n = int(input())
array = list(map(int, input().split()))
# 이거는 이차원 배열까지도 필요없음
dp = [1] * n

# 입력 배열 처음부터 끝까지 순회
for i in range(1, n):
    # 현재 칸보다 앞칸 순회 => 앞에있는 칸의 값이 뒤 값보다 작다면 => 부분수열
    for j in range(0, i):
        if array[j] < array[i]:
            # 현재 기록되어있는 부분수열의 최대 길이보다 크면 바꿔서 기록함
            # 아니면 유지
            dp[i] = max(dp[i], dp[j]+1)

print(max(dp))
