# 배낭에 넣을 수 있는 물건들의 가치의 최대값 => O(NK)
#! 모든 무게에 대하여 최대 가치를 저장하기
# D[i][j] => 배낭에 넣은 물품의 무게합이 j일때 얻을 수 있는 최대 가치
# 그리고 물건을 순회하면서 row를 증가시켜 나감
# row를 증가시켜 나가고 물건을 순회하면서 무게합 최대일때 가치를 기록함
# 물건을 넣을 수 있으면 이전의 최대무게 가치에다가 물건을 넣은 가치를 더함
# 넣을 수 없다면 이전 행의 값을 가져옴
#! 이전에 계산했던 값을 그대로 사용해서 더하면서 답에 가까워지는 상황에서 DP를 사용
#! 임의의 경우의 수나 순회를 해봐야 끝까지 알 수 있는 경우가 아니라
#! 점화식으로 딱 떨어질 수 있는 경우에 사용함

n, k = map(int, input().split())
dp = [[0] * k+1 for _ in range(n+1)]

for i in range(1, n+1):
    weight, value = map(int, input().split())
    for j in range(1, k+1):
        if j < weight:
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight] + value)

# 이렇게 DP테이블의 어느 한 부분에 문제의 답이 저장됨
print(dp[n][k])
