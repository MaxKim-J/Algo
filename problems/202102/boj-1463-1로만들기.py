
# * 은근 난해
n = int(input())

dp = [0 for _ in range(n+1)]

#! 약간 거꾸로 돌려서 i가 1이 될 수 있게 만드는 연산의 횟수를
#! i보다 작은 수가 1이 될 수 있게 만드는 연산의 횟수를 이용해서 구한다
#! 수는 어짜피 줄어나감
#! i를 1로 만드는 연산 횟수 = i가 i보다 작은 수가 되기 전의 연산 1번 + i보다 작은 수의 연산 횟수
#! i가 i보다 작은 수가 되기 전의 연산 == 3으로 나누기, 2로 나누기, 1빼기 => 이중에 뭐 하나 해주고 그 다음은 I보다 작은 수에서 이미 밝혀진 연산 횟수를 사용하면 됨

# dp 배열의 인덱스는 현재 인덱스가 1이 될때가지의 연산 횟수를 저장함
# 값은 index가 될때까지의 횟수
# 일단 1을 1로 만들기 위해서는 연산 개수 0개, 2부터 시작
for i in range(2, n+1):
    # 기본적으로 -1이 있으므로 거기다가 횟수 한번 더함
    dp[i] = dp[i-1] + 1

    # 만약 지금 숫자가 2로 나누어 떨어지는데
    # -1한 횟수보다 //2가 횟수를 떨어트릴 수 있다면 //2 + 1 적용
    if i % 2 == 0 and dp[i] > dp[i//2] + 1:
        dp[i] = dp[i//2] + 1

    # 만약 지금 숫자가 3으로 나누어 떨어지는데
    # -1한 횟수보다 //3가 횟수를 떨어트릴 수 있다면 //3 + 1 적용
    if i % 3 == 0 and dp[i] > dp[i//3] + 1:
        dp[i] = dp[i//3] + 1

# 이런 과정을 거듭하면 리스트 맨 끝에 답이 생김
print(dp[n])

# * 역시 정답 지향적으로 생각해야 한다. DP보드에 답을 남기려면 어캐해야되지? 생각하기

'''
# 얘는 그냥... 지가 DP라고 주장하는 간단한 BFS임

num = int(input())
count, temp = 0, [num]

while (1 not in temp):
    dp = set()
    #! 배열 하나를 계속 재사용 하는 방법은 대충 맞긔
    # 매번 해제되고 매번 다시 순회 => 매번 3개 이하의 숫자를 넣고 그거로 다시 순회
    # 최대 한 루프에 3번씩 순회
    # 같은 숫자가 2개 들어있지는 않음 => 2개 이상 평가할 필요는 없음
    # 1이 나올때까지만 반복하면 됨
    for n in temp:
        if n % 3 == 0:
            dp.add(n // 3)
        if n % 2 == 0:
            dp.add(n // 2)
        dp.add(n-1)
    count += 1
    temp = list(dp.copy())
print(count)
'''
