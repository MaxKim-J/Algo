# 백준 1931: 회의실 배정
# https://www.acmicpc.net/problem/1931
# 시간 : 60분+
# 경과 : 못품


def solution(InputArr):
    answer = 0
    endTime = 0
    for i in range(len(InputArr)):
        if endTime <= InputArr[i][0]:
            endTime = InputArr[i][1]
            answer += 1
    return answer


N = int(input())
InputArr = []

for i in range(N):
    A, B = map(int, input().split())
    InputArr.append([A, B])

InputArr.sort(key=lambda x: (x[1], x[0]))
print(solution(InputArr))

#! 접근) 정렬만 잘하면 다 먹고들어가는 문제였다 => 끝나는 시간이 가장 빠른 순으로 정렬 + 시작하는 시간의 오름차순으로 정렬
# *  key에 인자 두개주면 인자 순서대로 정렬 :  applies.sort(key=lambda x: (x[1], x[0]))
#! 테스트 케이스에 목매지 말자. 어떤 테스트 케이스를 고려해봐야되는지 직관적으로 생각해보자
"""
주어진 시작시간과 끝나는 시간들을 이용해서 가장 많은 회의의 수를 알기 위해서는 빨리 끝나는 회의 순서대로 정렬을 해야 한다. 이유는 간단하다. 빨리 끝날수록 뒤에서 고려해볼 회의가 많기 때문이다. 
빨리 시작하는 순서대로 정렬을 우선 한다면, 오히려 늦게 끝날 수 있기 때문이다.
간단한 예를 들자면

4
0 10
3 4
2 3
1 2
가 있을 때 시작 순서대로하면 (0 10)으로 1번의 회의가 가능하지만, 끝나는 시간으로 정렬을 한다면 (1 2) (2 3) (3 4) 총 3번의 회의가 가능해진다.

그리고 한가지 더 고려해야 하는 점이 있는데, 끝나는 시간이 같을 경우이다.
끝나는 시간이 같다면 빨리 시작하는 순서대로 정렬이 되어야 한다.
예를 들자면

2
2 2
1 2
의 경우 이 상태로 한다면 (2 2)가 되고 (1 2)는 (2 2)의 끝나는 시간보다 시작시간이 일찍이기 때문에 무시되어 1번의 회의가 진행된다고 나온다. 
하지만 정렬을 통해 (1 2)가 먼저 선택되면 (2 2)도 선택이 가능해지기 때문에 가능한 회의는 2번으로 결정된다.

그렇기 때문에 정렬을 1. 끝나는 시간의 오름차순 2. 시작하는 시간의 오름차순으로 해주어야 한다.
"""
