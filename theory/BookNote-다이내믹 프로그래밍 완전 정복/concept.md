# 동적계획법 아리까리했던 개념들 책보고 정리하는 문서

이미 알 것은 다 알고 있으니 빠르게 정리하고 넘어가기

## 개념

- 재귀를 사용할 때 : 재귀에는 항상 종료 조건이 있어야 하며, 종료 조건이 없다면 재귀 호출을 무한히 반복하게 됨. 
- 재귀 함수는 전체 작업의 일부만 수행하고 나머지는 재귀 호출에 위임함
- 최적 부분 구조(최적의 하위 구조) : n개의 원소를 가지는 문제를 풀때, 형태는 같지만 n 미만의 원소를 가지는 더 작은 크기의 문제의 풀이법을 사용하는게 최적의 풀이법이라면 이를 최적의 하위 구조 특성을 가진 문제라고 부름.
- 크기가 n인 문제에 대한 풀이법은 k < n인 k의 비슷한 문제의 관점에서 정의한다는 뜻이며, 더 작은 원소에 대한 최적의 풀이법들을 찾고 이를 결합해서 최종 풀이법을 완성한다.
- 어떤 문제의 점화식을 작성하거나 최적의 하위 구조를 정의하는 것이 첫번째 단계

## DP로 최적화 예제

### 최소 요금 계산 문제(DP로 재귀 최적화)

한 기차의 노선 위에 0부터 N-1까지 N개의 역이 있는데, 기차는 첫번째 역(0번 역)부터 마지막 역(N-1번역)까지 한 방향으로 이동함. 모든 두 역 사이의 기차 요금을 알고 있을때 0번 역에서 N-1까지 여행하는 최소 비용을 구하기

두 역 사이의 요금은 이차원 배열로 주어지고, 역방향으로는 이동하지 않기 때문에 역방향에 해당하는 인덱스는 -1로 주어짐

```python
cost = [
  [0,10,75,94],
  [-1,0,35,50],
  [-1,-1,0,80],
  [-1,-1,-1,0],
]
```

바로 가는것 보다 환승해서 다시 가는게 빠를수도 있다는 이야기임

#### 재귀 - O(2^n)

경우를 따지면

- 0번 역에서 목적지까지 한번에 갈 경우
- 1번 역에서 반드시 갈아타는 경우 (0-1요금과 나머지 구간 요금의 최솟값의 합)
- 2번 역에서 반드시 갈아타는 경우
- ...
- i번 역에서 갈아타는 경우 0번 역에서 i번 역까지의 최소 요금과 i번 역에서 N-1번 역까지의 최소 요금의 합을 구하기

```python
def minCost(s, d):
  # 출발역이 도착역과 같거나(0), 그 전 역인 경우 => 이미 정해져있음
  # 더 큰 문제인경우 더 쪼개야함
  if (s == d) or (s == d - 1):
    return cost[s][d]
  # 최초에는 0부터 끝가지 한번에 가는 경우 픽
  minValue = cost[s][d]
  # 최솟값을 찾기 위해서 모든 중간 역에 대해서 계산해봅니다.
  for i in range(s + 1, d):
    # s번 역에서 i번 역까지의 최소 요금과
    # i번 역에서 d번 역까지의 최소 요금의 합
    temp = minCost(s, i) + minCost(i, d)
    minValue = min(temp, minValue)
  
  return minValue
```

- 최적의 하위 구조 특성 : 출발역부터 도착역까지의 실제 최소 요금을 구하기 위해 중간 역들 사이의 최소 요금을 계산함 + 이런 계산을 여러번 반복함


#### 메모를 이용한 재귀(하향식 DP) - O(n^3)

재귀 호출 자체가 실행 시간과 메모리 관점에서 그리 좋지 않기 때문에, 반복되는 연산의 첫번째 연산 결과를 메모리에 저장해서 보관해둘 수 있다면 다음 연산을 계속 호출하지 않고 저장해둔 메모리를 들여다 보는 것 만으로도 결과를 상수시간에 구할 수 있게 됨

```py
# 메모로 사용할 캐시
memo = [[0] * 4 for i in range(0, 4)]

# 출발역(s)에서 도착역(d)까지의 최소 요금을 계산합니다.
def minCost(s, d):  
  if (s == d) or (s == d - 1):
    return cost[s][d]

  # 값이 계산되지 않은 경우에만 블록 안으로 들어가서 계산합니다.
  if memo[s][d] == 0:
    # 재귀 호출을 사용하는 코드와 비슷합니다.
    minValue = cost[s][d]

    for i in range(s + 1, d):
      temp = minCost(s, i) + minCost(i, d)
      minValue = min(temp, minValue)
    
    # 계산된 최소 요금을 캐시에 저장
    memo[s][d] = minValue
  
  # 값이 있는 경우 그냥 값 반환
  return memo[s][d]
```

- O(n^2)만큼 공간 복잡도가 추가되었고, O(n^3)만큼의 실행시간이 추가되었음. 재귀 호출을 사용하면 지수시간이 필요했던 것에 비하면 크게 개선됨
- 근데 결국 어짜피 재귀는 해야댐 = 하위 문제의 반복 계산 상황이 없다면 메모 전략은 실행 시간 측면에서는 재귀 접근 방시고가는 완전히 동일함

#### 동적 계획법(상향식 DP) - O(n^2)

0번까지의 최소 요금을 계산한 후 이어서 1번 역까지의 최소 요금, 2번 역까지의 최소 요금 등으로 계산해 올라가는 방식

- 0번까지의 최소 요금은 이동할 필요가 없으므로 0임
- 1번까지의 최소 요금은 단 한가지 경우 `cost[0][1]`
- 2번 역까지의 최소 요금은 `min(minCost[0] + cost[0][2], minCost[1] + cost[1][2]`
  - min(0에서부터 2까지 바로가는 경우, 1까지 가는 최소요금 + 1에서 환승해서 2까지 가는 경우)
- 이런식으로 하면 알 수 있는게 k번째 항을 구하기 위해서는 이전 몇개의 항만 필요하고 이전의 항 전부의 정보가 필요하지는 않을 수 있음 => 2번역까지의 최소 요금을 구할때 1번까지 어떻게 왔는지는 중요하지 않음 이미 최소값인 것이 보장되었으므로

```py
# 출발역(s)에서 도착역(d)까지의 최소 요금을 계산합니다.
def minCost(N):  
  # minValue[i] = 0번 역에서 i번 역까지의 최소 요금
  # cost[j][i] : j번 역에서 i번 역까지 바로 가는 요금
  dp = [0, cost[0][1]]

  # 2부터 시작
  for i in range(2, N + 1):
    dp.append(cost[0][i])
    for j in range(1, i):
      if dp[i] > dp[j] + cost[j][i]: # 최소값 계산
        dp[i] = dp[j] + cost[j][i]
  return minValue[N]
```

### 부분 문자열 다루기(DP로 완전탐색 최적화)

숫자로 이루어진 문자열이 있는데 이 숫자의 부분 문자열 중 앞부분 절반 숫자의 합과 뒷부분 절반 숫자의 합이 같은 부분 문자열 가운데 가장 긴 부분 문자열의 길이를 구하는 문제

찾아야 하는 부분 문자열의 길이는 짝수다 - 문자열을 앞뒤의 절반으로 나눌 수 있으려면 문자열의 길이는 짝수여야함

쉽게 말하면 문자열에서 도출되는 모든 부분 문자열 반씩 나눠서 좌우합 같은지 보는거임 문제만 보면 왜 꼭 짝수여야하지? 싶은 의문이 들지만 문제의 조건을 명시했다고 생각하고 넘어가쟈,,

#### 완전 탐색 - O(n^3)...보다 살짝 빠를듯

짝수 길이의 모든 부분 문자열에 대해 앞의 절반의 숫자의 합과 뒤의 절반의 숫자의 합이 같은지를 확인해보는 방식으로 풀 수 있다. 이를 검사하면서 부분 문자열의 길이를 저장해뒀다가 마지막에 모든 길이 중 최댓값 반환

```py
def maxSubStringLength(str):
  n = len(str)
  maxLen = 0

  # i = 부분 문자열의 시작 인덱스
  for i in range(0, n):
    # j = 부분 문자열의 끝 인덱스 (짝수 길이)
    for j in range(i + 1, n, 2):
      # length = 현재 부분 문자열의 길이
      length = j - i + 1

      #! 좋은 백트랙킹
      # 만약 지금까지의 maxLen이 검사하려는 문자열보다 길면
      # 현재 문자열을 검사(앞쪽과 뒤쪽 절반의 숫자의 합이 같은지)하지 않습니다.
      if maxLen >= length:
        continue      
      lSum = 0
      rSum = 0
      # 절반을 기준으로 나눠서 앞부분 더하고 뒷부분 더하고
      for k in range(0, int(length / 2)):
        lSum += int(str[i + k])
        rSum += int(str[i + k + int(length / 2)])
      if lSum == rSum:
        maxLen = length
  return maxLen
```

- 가장 직관적인 해결 방법이 반드시 재귀 호출을 사용하거나 지수 시간의 시간 복잡도인 것은 아니다. 
- 하지만 이 경우에도 반복해서 계산하는 하위 문제가 존재한다 : 123456이랑 345678을 평가할 때 두 경우 모두 4+5를 계산해야 함. 이전에 다른 문자열을 검사하는 과정에서 계산했음에도 또해야함 

#### 상향식 DP - 상수시간

DP로 반복 계산을 피할 수 있다. 부분 문자열의 숫자의 합을 구하는 가장 기본적인 경우는 부분 문자열의 글자가 한 글자인 경우. 두글자, 세글자로 늘려가면서 상향식으로 계산

- 길이 1의 부분 문자열 숫자의 합은 i번째 숫자의 값 그대로
- 길이 2의 부분 문자열 숫자의 합은 S(i,j) = S(i,i) + S(j,j) 이며 두개는 모두 계산되어 있음
- 길이 3인 부분 문자열 숫자의 합 S(i,j)는 한 글자 부분 문자열의 숫자의 합과 두 글자 부분 문자열의 숫자의 합임. 각각 1번과 2번 단계에서 계산되어있음
- 일반화 : `S(i,j) = S(i,k) + S(k + 1, j)`
- 이차원 배열의 DP테이블의 행과 열을 각각 i와 j로 잡음(시작과 끝)

```py
def maxSubStringLength2(str):
  n = len(str)
  maxLen = 0
  # sum[i][j] = 인덱스 i에서 인덱스 j까지의 숫자의 합(이차원배열 DP)
  # i > j인 경우에는 사용하지 않습니다.
  sum = [[0] * n for i in range(0, n)]


  # 행렬의 대각선 아래쪽(i > j)은 사용하지 않습니다.
  # 대각선 위치의 값을 채워 넣습니다.
  for i in range(0, n):
    sum[i][i] = int(str[i])

  for length in range(2, n + 1):
    # 현재 부분 문자열의 i와 j를 선택합니다.
    for i in range(0, n - length + 1):
      j = i + length - 1
      k = int(length / 2)
      # sum[i][j]의 값을 계산 => 전단계의 값 이용해서
      # 약간 ㄱ자로 계속 더함
      sum[i][j] = sum[i][j - k] + sum[j - k + 1][j]
      # length가 짝수이고, 왼쪽과 오른쪽 절반의 합이 같으며 
      # length가 maxLen보다 크면 maxLen을 갱신합니다.
      if (length % 2 == 0) and (sum[i][j - k] == sum[j - k + 1][j]) and length > maxLen:
        maxLen = length
  return maxLen
```

## 하향식 VS 상향식

하향식 접근 방법은 먼저 목적지를 인식하고 거기에 도달하기 위한 수단을 강구함. 반면 상향식 접근법에서는 사용 가능한 모든 수단을 확보한 후 목적지로 이동

- 하향식 : 재귀로 존나 열심히 호출한 함수를 스택에 쌓으며, 위에 있는 큰 문제를 아래로 쪼개며 계속 내려가고 분해하다가 바닥조건이 시작되는 지점부터 값을 뿜으며 연산을 시작. 최상단의 경우부터 문제를 조망하며 상황을 폭넓게 이해하기 때문에 더 직관적임
  - 이진 트리 프리오더 : 왼쪽 서브트리로 계속 재귀적으로 내려가는 경우
- 상향식 : 가장 작은 문제부터 최적값을 만들면서 동시에 계산하며 아래에서 위로 올라가는 듯 한 모습을 취함 
  - 상향식 방법을 만들기 위해 최상단의 경우를 내가 머리써서 분해해야할 경우가 생기긴 함

### 하향식이 더 나은 경우 : 파스칼의 삼각형

- 하향식 접근 방법에서는 모든 하위 문제를 풀지 않고 전체 문제의 해답을 얻는데 필요한 하위 문제만 풀었음. 상향식 다이나믹 프로그래밍에서는 전체 문제의 풀이에 도달하기 전 모든 하위 문제에 대해 계산을 수행함.
- 드물게 실제 필요한 것보다 훨씬 많은 하위 문제를 풀어야 하는 경우가 있는데 이런 경우에는 하향식이 입력이 커지면 커질수록 효율이 높아짐
- 막 와닿진 않는다

## (책에서 제시하는) 전략

### 어떤 문제에 DP를 적용하나?

- 문제가 최적의 하위구조를 가지고 있는지, 그리고 하위 문제를 반복해서 계산하는지 찾아봐야 함
- 어떤 값을 최적화, 최대화, 최소화, 경우의 수를 찾는 문제에 해당하며 이런 문제들이 최적의 하위구조를 가지고 있다면 DP를 고려해보는 것도 괜찮음

### 단계

- DP를 쓸 수 있는지 타진(위의 조건들로)
- 점화식 또는 재귀 과정을 정의
  - 하위 문제 사용해 하향식으로
  - 기본 경우에 대한 답을 정의
  - 종료 조건
- 풀어야하는 DP 문제들은 대부분 상향식이긴 해서.. 일단 상향식처럼 생각하고, 좀 이상한 문제일때 하향식도 좀 생각해 보기(최적화가 잘 안된다거나,,, 하면)