# 책에서 나온 예제들 정리

뭔가 DP를 어캐짜냐 보다 재귀를 어캐짜냐를 배우는것같은 이번 공부...

## 1. 최소 교정 비용 문제

두 단어가 주어지고 첫번째 단어(str1)에서 수행할 수 있는 연산은 삽입, 삭제, 치환  
두 단어 간의 교정 비용은 한 단어에서 다른 단어로 바꾸는데 필요한 글자 연산의 횟수  
str1에서 str2로 바꾸는데 필요한 연산의 최소 개수를 구하는 프로그램 작성하기

> str2를 삼아서 이전의 경우가 삽입 삭제 치환 3가지 경우로 그 다음에 온 경우를 상향식 풀이를 하면 되겠군!

### 재귀

- 같은 유형을 가진 작은 문제 : 두 글자가 같다면 양쪽 단어의 첫번째 글자에 대해서는 아무것도 하지 않아도 됨
- 삭제 : 첫 글자 삭제하고 난 후 첫 글자가 삭제된 str1 str2 사이의 최소 교정 비용
- 치환 : str1의 첫글자를 str2의 첫글자로 치환한 다음 양쪽의 첫 글자를 제외한 단어간의 최소 교정 비용
- 삽입 : str2의 첫 글자를 str1의 제일 앞에 삽입한 다음 양족 단어의 첫번째 글자를 제외한 나머지 단어의 교정 비용(삽입하고 나면 첫글자가 같아지므로)
- 연산 이후의 최소 교정 비용은 재귀 호출에 맡기기. 각 재귀 호출의 결과 중 제일 최솟값에 1을 더해 반환(어떤 연산이든 수행했던 경우에)

```py
def editDistance(str1, str2):
  #! 바닥조건
  # str1이 빈 문자열이면 str2의 모든 글자를 삽입하면 됩니다.
  if (str1 is None) or (len(str1) == 0):
    return len(str2)
  # str2가 빈 문자열일때도 마찬가지입니다.
  if (str2 is None) or (len(str2) == 0):
    return len(str1)

  # 첫번째 글자가 같을 때는 첫번째 글자를 무시하고
  # 나머지 단어 간의 최소 교정 비용을 구합니다.
  if str1[0] == str2[0]:
    return editDistance(str1[1:], str2[1:])

  # 삭제 연산 후 최소 교정 비용을 구하는 재귀 호출
  d = editDistance(str1[1:], str2)
  # 치환 연산 후 최소 교정 비용을 구하는 재귀 호출
  u = editDistance(str1[1:], str2[1:])
  # 삽입 연산 후 최소 교정 비용을 구하는 재귀 호출
  i = editDistance(str1, str2[1:])

  # 세 연산 이후 최소 교정 비용 간의 최솟값에 1을 더해서 반환합니다.(뭐든 연산을 햇기 때문에)
  # 요런거 쉽게 생각하기 힘들지도
  return min([d, u, i]) + 1
```

- O(3^n) : 자식이 계속 3개인 트리, 재귀 호출 과정에서 같은 하위 문제를 여러번 반복해서 계산

### DP

- 두 단어의 교정 비용을 구하는 과정에 필요한 모든 가능한 조합에 대해서 교정 비용을 상향식으로 구하기
- DP 테이블을 각 두 문자열의 원래 갯수에 맞춰 이차원 배열로 준비한다
- 이차원 배열의 (i,j) 값은 str1의 첫 i개의 글자와 str2의 첫 j개의 글자 사이의 최소 교정 비용의 값 => 계속 사용이 가능하다
- 행렬의 값을 모두 채우고 난 후 가장 우하단의 값이 최소 교정비용이 됨
- 첫번째 단어가 빈 문자열일 때 두 단어를 똑같이 만드려면 두 번째 단어의 모든 글자를 첫번째 단어에 삽입하거나 두번째 단어의 모든 글자를 삽입하면 되므로 글자수와 같다
- 점화식 : 두 글자가 같으면 교정비용의 차이가 없으므로 대각선 방향 왼쪽 위 셀을 그냥 가지고 온다(그 글자에 대해 추가되는 비용이 없음), 그렇지 않은 경우 치환삽입삭제 3가지 연산 중 교정비용이 가장 적은 것을 dp테이블에서 적당히 가져오고 1을 더 더해줌(연산을 했으므로)

```
dp[i][j] = if 두 글자가 같은 경우 dp[i-1][j-1] else min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
```

- 이렇게 문자열 다루는 DP 중에서는 저렇게 글자 수를 DP 테이블의 행과 열로 처리하는 느낌으로 풀면 좋을것 같은게 좀 있음

```py
def editDistance(str1, str2, m, n):
  dp = [[0] * (n + 1) for i in range(0, m + 1)]

  for j in range(0, n + 1):   # 제일 위 행
    dp[0][j] = j

  for i in range(0, m + 1):   # 제일 왼쪽 열
    dp[i][0] = i

  # dp 테이블을 전부 순회
  for i in range(1, m + 1):
    for j in range(1, n + 1):
      # 두 글자가 같다면
      if str1[i - 1] == str2[j - 1]:
        dp[i][j] = dp[i - 1][j - 1]
      # 두 글자가 다르다면
      else:
        dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1

  return dp[m][n]
```

- O(n^2), 공간복잡도 O(n^2)추가 : 지수시간에서 ^2시간으로...

## 2. 직사각형에서 총 경로 수 구하기

M\*N개의 방으로 구성된 직사각형이 있을 때 좌상단 방에서 우하단 방까지 이동하는 **모든 경우의 수**  
방과 방 사이의 이동은 오른쪽 방향과 아래쪽 방향으로만 가능

### 재귀

- 방 (m,n)은 다른 두 방에서 접근 가능하다 : (m-1, n), (m, n-1)
- 종료 조건은 위쪽 경계나 왼쪽 경계에 도달했을 때
- 0,0번방은 이동하는 경우가 0개
- 첫번째 행에서의 이동, 첫번째 열에서의 이동 : 쭉 이동하는 한가지 경우

```py
# 걍 그대로 구현하면 됨

def numOfPaths(m, n):
  if (m == 0) and (n == 0):   # 방 (0, 0)
    return 0
  if (m == 0) or (n == 0):    # 첫번째 행 또는 첫번째 열
    return 1

  # 재귀 호출
  return numOfPaths(m - 1, n) + numOfPaths(m, n - 1)
```

- O(2^n) : 자식이 계속 2개인 트리, 역시 같은 문제를 계속 반복해서 푸는 상황

### DP

- 방을 나타내는 이차원 배열 입력이 그대로 DP 테이블이 됨
- 재귀의 종료 조건으로 설명한 바 그대로 첫 행과 첫 열을 채울 수 있음

| 0   | 1   | 1   | 1   |
| --- | --- | --- | --- |
| 1   |     |     |     |
| 1   |     |     |     |

- 점화식 : 간단, 두 방향으로 오니까 `dp[i][j] = dp[i - 1][j] + dp[i][j-1]`
- 최종적으로 채운 배열은

| 0   | 1   | 1   | 1   |
| --- | --- | --- | --- |
| 1   | 2   | 3   | 4   |
| 1   | 3   | 6   | 10  |

```py
def numOfPaths(m, n):
  dp = [[0] * n for i in range(0, m)]

  # 바닥조건
  for i in range(1, m):
    dp[i][0] = 1

  for j in range(1, n):
    dp[0][j] = 1

  # 전체 DP 테이블 순회하며 채우기
  for i in range(1, m):
    for j in range(1, n):
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]

  # 맨 우하단의 값 리턴
  return dp[m - 1][n - 1]
```

## 3. 문자열 인터리빙 확인 문제

두 문자열 A, B가 있는데 이 문자열 내의 모든 글자의 상대적인 순서가 유지된 채 섞여서 새로운 문자열 C가 만들어지면 이때 문자열 C를 문자열 A와 문자열 B의 인터리빙이라고 부름  
xyz와 abcd가 있으면 xabyczd는 xyz와 abcd의 인터리빙  
세 개의 문자열 A, B, C가 주어졌을 때 세번째 문자열이 앞의 두 문자열의 인터리빙인지를 검사하는 함수를 작성하기

> 이것도 약간 병합정렬식으로 재귀 돌리면 풀릴듯? DP로는 인덱스를 유지한채 a에서 온거랑 b에서 온거랑 분리해서 맞으면 계속 가고 이러면 될거같은데

## 재귀

- C의 길이가 A, B 길이 합과 같지 않다면 애초부터 아님
- C의 길이가 A와 B의 합과 같은 경우에만 다음 과정으로 넘어감
- xabyczd, xyz, abcd일때
- 반복되는 문제 캐치 : 첫번째 글자 x는 b의 첫번째 글자가 아니므로 A에서 가져온 것임이 분명함. 이때 A를 하나 날려서 이제 문자열 yz와 문자열 abcd의 인터리빙인지를 확인하는 작은 문제로 바뀜... 계속 반복
- 만약 A에서 온 것일수도 있고 B에서 온 것일수도 있을 경우 양쪽 모두를 확인해봐야함

```py
def isInterleaving(A, B, C):
  # 만약 모든 문자열이 빈 문자열인 경우
  if (len(A) == 0) and (len(B) == 0) and (len(C) == 0):
    return True

  # A와 B 문자열의 길이의 합이 C 문자열의 길이와 다를 때
  if len(A) + len(B) != len(C):
    return False

  caseA = False
  caseB = False

  # A의 첫글자와 C의 첫글자가 같은 경우
  if (len(A) != 0) and (A[0] == C[0]):
    caseA = isInterleaving(A[1:], B, C[1:])

  # B의 첫글자와 C의 첫글자가 같은 경우
  if (len(B) != 0) and (B[0] == C[0]):
    caseB = isInterleaving(A, B[1:], C[1:])

  # 가능한 케이스는 끝까지(뭔지 밝혀질때까지) 하향식으로 계산된다
  return caseA or caseB
```

- 가능한 케이스에 대해 모두 연산을 수행하고, 하향식으로 가능한 케이스가 끝까지 계산되기 때문에 당연히 반복되는 연산이 많아보인다
- O(2^n) : 2개의 자식이 반복되는 트리이므로 지수시간

## DP

- 각 단계마다 C의 부분 문자열이 A의 부분 문자열과 B의 부분 문자열의 인터리빙인지를 확인함
- 역시 이것도 각 문자 하나하나를 행과 열로 하는 DP 테이블이 필요하고, 참 거짓 여부를 채운다.
- 행렬의 (i,j)값은 C'가 A'와 B'의 인터리비잉면 참이 됨
- (0,0)은 빈 문자열 두개를 인터리빙해도 빈 문자열이기 때문에 무조건 참으로 시작함
- 첫번째 행은 문자열 A가 빈 문자열인데 이때는 B의 부분 문자열이 C의 부분 문자열과 같으면 참(그냥 그 안에 모두 넣을 수만 있으면)
- 테이블을 채워나가는 방법은 4가지가 가능함
  - C의 현재 글자가 A의 현재 글자와 B의 현재 글자 어느쪽과도 다른 경우, 이때 셀의 값은 거짓
  - C의 현재 글자가 A의 현재 글자와 같지만 B의 현재 글자와 다를 경우, 이때 셀의 값은 바로 위 셀의 값(A의 참거짓)
  - C의 현재 글자가 B와 같지만 A와는 다른 경우 이때 셀의 값은 바로 왼쪽 셀의 값(B의 참거짓)
  - A,B,C현재 글자가 모두 같은 경우 이때 셀의 값은 위쪽 셀의 값이나 오른쪽 셀의 값 둘 중 하나가 참이면 참

```py
def isInterleaving(A, B, C):
  # A, B, C 세 문자열의 길이를 구합니다.
  M = len(A)
  N = len(B)
  lengthC = len(C)

  # A와 B 문자열의 길이의 합이 C 문자열의 길이와 다를 때
  if lengthC != M + N:
    return False

  # 인터리빙 여부를 저장하는 2차원 배열
  ilMatrix = [[True] * (N + 1) for i in range(0, M + 1)]

  # 첫번째 열을 채웁니다.(열길이 기준)
  for i in range(1, M + 1):
    if A[i - 1] != C[i - 1]: # 같지 않으면 무조건 false로 채움 => 문자열 하나만으로 인터리빙을 만들어야 하기 때문
      ilMatrix[i][0] = False
    else:
      ilMatrix[i][0] = ilMatrix[i - 1][0] # 바로 위에 꺼

  # 첫번째 행을 채웁니다. (행길이 기준)
  for j in range(1, N + 1):
    if B[j - 1] != C[j - 1]: #
      ilMatrix[0][j] = False
    else:
      ilMatrix[0][j] = ilMatrix[0][j - 1] # 바로 옆에꺼 그냥 가져옴

  # 나머지 셀을 채웁니다.
  for i in range(1, M + 1):
    for j in range(1, N + 1):
      currantA = A[i - 1]
      currentB = B[j - 1]
      currentC = C[i + j - 1]
      # C의 글자가 A의 글자와 같고 B의 글자와 다를 때
      if (currantA == currentC) and (currentB != currentC):
        ilMatrix[i][j] = ilMatrix[i - 1][j]
      # C의 글자가 B의 글자와 같고 A의 글자와 다를 때
      elif (currantA != currentC) and (currentB == currentC):
        ilMatrix[i][j] = ilMatrix[i][j - 1]
      # A, B, C 글자 모두가 같을 때
      elif (currantA == currentC) and (currentB == currentC):
        ilMatrix[i][j] = ilMatrix[i - 1][j] or ilMatrix[i][j - 1]
      else:
        ilMatrix[i][j] = False

  # 완성된 행렬을 출력합니다.
  for i in range(0, M + 1):
    for j in range(0, N + 1):
      print('%s' % 'T ' if ilMatrix[i][j] else 'F ', end = '')
    print()

  return ilMatrix[M][N]

```

- 불리언을 DP 테이블에 넣어 연관성있게 다른 칸의 값도 나오는게 좀 유형이 신기한 문제였던 것 같음
- O(n^2)로 반복되는 연산을 메모이제이션하기 때문에 시간이 줄어든다.

## 4. 부분집합의 합 구하기

0과 양의 정수로 이루어진 집합이 있고 또 다른 양의 정수 X가 있을 때 주어진 집합의 부분집합 중에 원소의 합이 X인 부분집합이 존재하는지 검사하는 함수 작성하기

### 재귀

- 두 가지 가능성
  - 부분집합에 X를 포함한다면 집합의 나머지에서 합이 X-P가 되는 부분집합을 찾아야 함
  - 부분집합에 X를 포함하지 않는다면 집합의 나머지에서 합이 X가 되는 부분집합을 찾아야 함
- 재귀 호출의 종료 조건은 X가 0이 되었는지(X를 줄여나가면서 재귀를 돌림), 혹은 집합 내의 원소를 모두 사용했는데 X가 0이 아닐때.
- 특수한 경우로는 원소의 값이 X보다 큰 경우인데, 이런 원소는 재귀호출 없이 부분집합에 포함하지 않아도 됨(그거 하나 넣으면 이미 넘쳐버림)

```py
def isSubsetSum(arr, n, X):
  # 종료 조건 1 : X가 0이면 성공 종료 조건입니다.
  if X == 0:
    return True

  # 종료 조건 2 : X가 0이 아니고 남은 원소가 없다면 실패 종료 조건입니다.
  if n == 0:
    return False

  # X보다 큰 원소는 무시해도 좋습니다.(안 넣는다)
  if arr[0] > X:
    return isSubsetSum(arr[1:], n - 1, X)

  # 맨 앞에꺼 가지고 어떻게 할지 정하는데
  # 부분집합에 원소를 포함시키지 않는 경우와
  # 원소를 포함시키는 경우 각각에 대해 재귀 호출합니다. => 선형 + 재귀 아이디어로 부분합 구하기 넣고갈거냐 빼고갈거냐
  return isSubsetSum(arr[1:], n - 1, X) or isSubsetSum(arr[1:], n - 1, X - arr[0])
```

- 명백하게 반복계산이 이루어지고 있음 - 경우의 수 마다 어떤 특정 수 X를 반복해서 넣으며 X를 줄이거나 하기 때문에 : O(2^n)

### DP

- DP 테이블은 이차원 배열로, 행은 합 열은 부분집합의 숫자들
- `dp[i][j]`는 집합의 첫 (i+1)개의 원소로 구성된 집합에 대하여 합이 0 <= j <= X인 부분집합에 대한 **참/거짓** 값
- 첫번째 열은 모두 참임 공집합인 부분집합의 원소의 합은 언제나 0이기 때문
- 첫번째 행은 행의 첫번째 숫자인거만 참

| 수\합 | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| ----- | --- | --- | --- | --- | --- | --- | --- |
| 3     | T   | F   | F   | T   | F   | F   | F   |
| 2     | T   |     |     |     |     |     |     |
| 7     | T   |     |     |     |     |     |     |
| 1     | T   |     |     |     |     |     |     |

- 나머지 행을 채워나가는데, 이때 채워나가는 과정에서 각 행에 해당되는 값을 v라고 하면 처음 v칸 만큼은 바로 위쪽의 행을 복사함. 부분집합에 그 숫자 하나 더 추가되었다고 해서 더 작은 합을 만드는 데에는 영향을 주지 않기 때문
- 나머지 셀들은
  - (i-1, j)가 T면 (i,j)도 T : 부분집합에 이미 V를 포함하지 않고도 합을 만들 수 잇음
  - 그 밖의 경우는 (i-1, j-v) 셀의 값을 (i,j)로 복사 : (이전 행, 만들어야되는 숫자 - 부분집합에 새롭게 들어온 숫자 = 새로운 숫자가 없을때 해당 합 만드는게 가능했는지, 새로운 숫자 더했을때 합만큼 딱 구해야 하는 전체 합수가 늘어났는지)
- 세번째 행같은 경우 합 6을 만드는데 7은 아무런 소용이 없으므로 바로 위 행을 그대로 복사해서 만들면 됨
- 우하단 셀의 값이 답

| 수\합 | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| ----- | --- | --- | --- | --- | --- | --- | --- |
| 3     | T   | F   | F   | T   | F   | F   | F   |
| 2     | T   | F   | T   | T   | F   | T   | F   |
| 7     | T   | F   | T   | T   | F   | T   | F   |
| 1     | T   | T   | T   | T   | T   | T   | T   |

```py
def isSubsetSum(arr, n, X):
  subsum = [[False] * (X + 1) for i in range(0, n)]

  # 첫번째 열은 항상 참
  for i in range(0, n):
    subsum[i][0] = True

  # 첫번째 행은 j가 0 또는 arr[0]인 경우만 참
  for j in range(1, X + 1):
    if arr[0] == j:
      subsum[0][j] = True
    else:
      subsum[0][j] = False

  # 나머지 셀을 채웁니다.
  for i in range(1, n):
    v = arr[i]
    for j in range(1, X + 1):
      if j < v:
        subsum[i][j] = subsum[i - 1][j] # 영향 주지 않으므로 그대로 가져옴
      elif subsum[i - 1][j]:
        subsum[i][j] = True # 이미 포함하지 않고도 합을 만들 수 있으므로 T를 그대로 가져옴
      else:
        subsum[i][j] = subsum[i - 1][j - v]
        # 만들려는 합수에서 추가되는 수만큼 빼고 추가되는 수가 없다고 가정했을 때 이미 합수를 만들수 있었느냐를 타진

  # 완성된 행렬을 출력해봅니다.
  for i in range(0, n):
    for j in range(0, X + 1):
      print('%s' % ('T ' if subsum[i][j] else 'F '), end = '')
    print()

  return subsum[n - 1][X]
```

- 얼핏 보면 for문을 대충 두겹 돌리니 O(n^2)같지만 X는 상수이고 입력 집합의 길이와 무관한 값이므로 O(n)이 됨 진짜 많이 줄었네

## 5. 최장 공통 부분 수열 길이

문자열 X의 부분 수열은 문자열 내에서 왼쪽에서 오른쪽 방향으로 문자열 내에 들어있는 글자의 수열.  
길이가 n인 문자열의 부분 수열의 개수는 2^n개임. 부분 수열에는 빈 수열과 원래의 문자열도 포함  
문자열 X와 Y가 주어졌을 때 X의 부분 수열이기도 하고 Y의 부분 수열이기도 한 문자열을 X와 Y의 공통 부분 수열이라고 하고, 공통 부분 수열 중 가장 긴 부분 수열을 최장 공통 부분수열이라고 함

### 재귀

- 두 문자열의 가장 마지막 글자를 비교하며 시작함. 마지막 글자를 비교할 때 몇가지 경우가 있는데
- 두 글자가 같은 경우 : 이 경우 이 글자가 두 문자열의 LCS의 마지막 글자가 됨. LCS에 들어가는 글자 하나를 찾아냈음
- 두 글자가 다른 경우 : 이 경우는 다음 두 LCS의 길이를 구해서 이중 큰 값을 반환함
  - 문자열 A의 마지막 글자를 제외한 문자열과 문자열 B의 길이 LCS(A에서만 하나 뺀 경우)
  - 문자열 A와 문자열 B의 마지막 글자를 제외한 문자열의 LCS(B에서만 하나 뺀 경우)

```py
# m과 n은 맨 끝부터 가리키는 포인터. 재귀가 거듭될수록 줄여 나간다

def lcs_length(X, Y, m, n):
  # 종료 조건은 두 문자열 중 하나가 빈 문자열일 때이며,
  # 이때의 LCS_LENGTH는 0입니다.
  if (m == 0) or (n == 0):
    return 0

  # 문자열의 마지막 글자를 비교해 조건에 따라 재귀 호출합니다.
  if X[m - 1] == Y[n - 1]:
    return 1 + lcs_length(X, Y, m - 1, n - 1)
  else:
    return max(lcs_length(X, Y, m, n - 1), lcs_length(X, Y, m - 1, n))
```

- 지수 시간. 최악의 경우는 두 문자열에 겹치는 글자가 하나도 없을 때인데, 모든 경우마다 두개씩 분기로 나뉘어 재귀가 계속 발생함 트리가 계속 두개로 갈림

### DP

- 이번에도 A와 B의 글자 하나하나를 DP 테이블의 행과 열로 놓음
- 문자열 X의 첫 i 글자와 Y의 첫 j글자를 처음 계산할 때 이 값을 테이블 `[i][j]`에 저장함.

```py

M_MAX = 30
N_MAX = 30

def getMax(a, b):
  return a if a > b else b

def lcs_length(X, Y, m, n):
  dp = [[0] * (n + 1) for i in range(0, m + 1)]

  # 첫번째 열을 0으로 채웁니다. : 빈문자열과 문자열의 공통수열은 없음
  for i in range(0, m + 1):
    dp[i][0] = 0

  # 첫번째 행을 0으로 채웁니다. : 마찬가지
  for j in range(0, n + 1):
    dp[0][j] = 0

  # 배열의 나머지 셀을 채웁니다.
  for i in range(1, m + 1):
    for j in range(1, n + 1):
      if X[i - 1] == Y[j - 1]:
        dp[i][j] = dp[i - 1][j - 1] + 1
        # 대각선 좌측의 공통수열 길이에 새 문자를 추가했고 그게 같으므로 그 결과에서 1을 더함
      else:
        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        # 같지 않으면 왼쪽, 혹은 위의 결과에서 더 큰값을 가져옴(이미 만들어진 수열중 큰거를 가져와서 계속 진행)

  return dp[m][n]
```

- 우하단 값이 정답
- M과 N이 적당히 적은 정수이기 때문에 선형시간에 풀림

## 6. 최장 공통 부분 수열 출력

- DP 테이블 역추적 스킬 : 이거 가끔 활용해야할 때 있는듯. DP 테이블로 값을 다 구해냈을때 특정 결과값을 요구하는 문제가 있다. 나동빈 필수예제에서 풀어봄 그... 돌탑쌓기?
- DP 테이블을 채워나가는 동안 각 셀이 어떤 셀의 값을 사용해 채워졌는지 생각해보기. 행렬의 모든 셀은 다음 셋중 하나의 값으로 채워짐
  - 왼쪽 셀과 같은 값(길이 유지)
  - 위쪽 셀과 같은 값(길이 유지)
  - 왼쪽 위 셀의 값 + 1(한글자 추가)
- 우하단부터 시작해서 좌상당 행까지 경로를 따라 이동해가면서 한글자가 추가된 경우에 해당되는 글자를 하나씩 LCS의 맨 앞에 삽입해나감. DP테이블을 거꾸로 따라가고 있기 때문에 큐처럼 앞에 삽입

```py
  length = dp[m][n]
  LCS = ''

  # 끝의 수
  i = m
  j = n

  while (i > 0) and (j > 0):
    # 행열 문자열이 같은거면 원래 DP테이블이 그때 문자열을 추가한 것이므로
    # 그 글자가 곧 LCS의 일부다
    if X[i - 1] == Y[j - 1]:
      LCS = X[i - 1] + LCS
      i -= 1
      j -= 1
    # 아니면 그냥 줄여서 감
    elif dp[i - 1][j] > dp[i][j - 1]:
      i -= 1
    else:
      j -= 1
```

## 7. 거스름돈 최적화

- 액면가가 다른 여러 종류의 동전을 제한 없이 사용할 수 있다고 할때, 어떤 금액으 ㄹ지불하는데 사용할 수 있는 동전 개수의 최솟값
- 밑에 철근 자르기도 그렇고, 선형 배열을 DP테이블로 활용하는 방법. 뭔가 계속 해보면서 셀을 채워 나가는 류의 문제가 아니라 되게 다양한 레이블을 붙인 계산 결과값들이 다양하게 활용될때 사용한다. 좀더 진정한 의미의 메모이제이션? 이랄까?

### 그리디

- 각 선택마다 사용 가능한 가장 큰 액면가의 동전을 사용하기
- 동전의 개수를 줄이려면 더 작은 액면가의 동전으로 만든 금액이 상위 액면가 동전의 액면가보다 작아야 함. 즉 1원 동전으로 거슬러줄 수 있는 금액은 상위 액면가 동전의 액면가인 5원 미만이어야 함(남은 금액이 상위 동전보다 작아야 밑의 동전을 사용할 수 있음)
- 결과적으로 50원짜리 동전을 사용할 수 있는 만큼 사용한 다음 그 다음 액면가인 동전을 또 사용할 때까지 사용하는 방식으로 최적화가 가능한 문제임
- 탐욕 알고리즘은 가능한 모든 경우를 전부 검사하지 않는다는 점에서 DP랑 통하는 바가 있음. 그러므로 탐욕을 사용해 효율적으로 풀 수 있는 종류의 문제도 있음. 하지만 모든 경우에 사용할 수 있는 것은 아니므로, DP로도 가능함
- 만약에 동전의 액면가가 다르면 그리디로 최적해가 안나옴. 12원짜리 동전이 있다고 생각해보면 50원쓰고 12원 개써서 1원짜리 짤짤이가 막 남으면 최적해가 아니게 됨

### 재귀

- 사용 가능한 동전의 종류가 N일때 S를 지불하는데 필요한 동전의 최소 개수를 재귀를 사용해 정의할 수 있음.
- 종료 조건은 지불하는 금액이 0이 되었을때이며, 이때는 동전이 필요하지 않으므로 0을 반환

```py
S_MAX = 997
resultArray = [-1] * (S_MAX + 1)

def minCoins(coin, N, S):
  # 종료 조건
  if S == 0:
    return 0

  # 메모도 구현(액면가 S를 지불할 수 있는 최소 동전의 개수를 저장)
  if resultArray[S] != -1:
    return resultArray[S]

  # 최솟값을 저장하는 변수입니다.
  result = S_MAX
  for i in range(0, N):
    # 액면가가 S보다 같거나 작은 모든 동전에 대해서 재귀 호출합니다.
    # 동전을 선택할 수 있는 모든 경우에 대해 재귀호출
    if coin[i] <= S:
      temp = minCoins(coin, N, S - coin[i])

      # 지금까지의 최솟값보다 더 작으면 최솟값을 교체(동전 개수)
      if temp + 1 < result:
        result = temp + 1

  resultArray[S] = result
  return result
```

- 지수 시간 복잡도에, 코드도 좀 직관적이진 않은듯.

### DP

- 작은 액수부터 큰 액수의 방향으로 구해나간다

```py
def minCoins(coin, N, S):
  # 선형배열 DP 테이블, 지불액수만큼 다 넣어놓기(1원으로 지불할 수 있는 최대의 동전개수 == 지불개수)
  # dp는 동전의 개수를 저장함
  dp = [S + 1] * (S + 1)

  # S = 0일 때. 바닥조건
  dp[0] = 0

  # 1원부터 계산해 올라갑니다.
  # 1원을 지불할때의 지불 방법 구하기
  for i in range(1, S + 1):
    # 동전 모두순회
    for j in range(0, N):
      # 현재 구하려는 금액보다 작은 액면가의 동전에 대해서만 검사(지불가능한 동전만)
      if coin[j] <= i:
        temp = dp[i - coin[j]] # 지불금액 - 동전만큼 뺐을때 이전에 구했던 값 재활용
        #  (temp가 지불금액이 아니어야 하고 - 최댓값) and (min인지 검사)
        if (temp != S + 1) and (temp + 1 < dp[i]):
          dp[i] = temp + 1 # 테이블 갱신

  return dp[S]

coin = [1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000] # 동전들
N = len(coin) # 동전의 종류의수
S = 997 # 지불금

minCoins(coin, N, S)
```

## 8. 철근 자르기

철근은 길이에 따른 서로 다른 가격으로 판매됨. 특정 길이의 철근이 있을 대 이를 어떻게 잘라서 파느냐에 따라 이익이 달라질 수 있음. 철근의 가격은 주어짐. 길이가 n인 철근이 있을 때 이 철근을 팔아서 얻을 수 있는 이익의 최댓값을 구하는 함수 작성하기

### 재귀

- 가격표는 인덱스가 곧 길이
- 가능한 모든 조합을 구하고 각 조합의 판매 금액을 계산해서 이중 최댓값을 반환하는 재귀 로직을 짜면 됨

```py
ENOUGH_MIN = -99999999
# value[i]는 길이 i인 철근의 가격입니다.
# N은 철근의 길이
def dp(value, N):
  # 종료 조건 : 남은 철근이 없을 때
  if N <= 0:
    return 0

  # 최대 이익
  price = ENOUGH_MIN

  # N까지 순회하면서 지금의 가격이랑
  # 순회한 철근을 잘라 팔아 만든 가격이랑 비교해서
  # 더 큰쪽이 계속 살아남음
  for i in range(1, N + 1):
    price = max(price, value[i] + dp(value, N - i))

  return price
```

- 크기 N인 최종 목적의 답을 계산하는 과정 중에서 N보다 작은 값에 대해 dp 함수를 반복 호출하는 일이 발생함 - 지수시간

### DP

- 길이 0에서 시작해 N으로 올라간다.

```py
ENOUGH_MIN = -99999999

# value[i]는 길이 i인 철근의 가격입니다.
def dp(value, N):
  # dp[i] : 길이 i인 철근을 팔 때의 최대 이익 - 선형 배열에 저장
  dp = [ENOUGH_MIN] * (N + 1)

  dp[0] = 0  # 길이 0인 철근의 가격은 0

  # 길이 1에서 N까지 계산해 올라갑니다.
  for i in range(1, N + 1):
    # 길이 i인 철근은 i 길이에 해당되는 가격표(value[i])까지만 필요합니다. => 그 밑에까지 분할 가능
    for j in range(1, i + 1):
      # 분할해서 팔기 vs 그냥팔기 중에 큰거 저장
      dp[i] = max(dp[i], value[j] + dp[i - j])

  # 원래 철근의 길이 인덱스가 답
  return dp[N]
```

## 9. O-1 배낭

냅색 문제

도둑이 가져온 배낭에는 최대 무게 C까지 물건을 넣을 수 있음. 물건을 쪼개서 일부만 들고 나갈 수 없다고 할때 도둑이 들고 나갈 수 잇는 물건 가격의 최댓값을 반환하는 함수를 작성(무게의 제한이 있을때 최대로 넣을 수 있는 물건 가격 총합 구하기)

### 재귀

- 도둑은 각 물거남다 그 물건을 배낭에 넣을지 말지 두 가지 선택이 가능함
- 물건이 n개 있다고 할때 n번 물건에 대한 선택은 다음과 같이 두가지
  - 물건을 배낭에 넣을 때 : 이 경우 물건은 n-1개가 남느며, 배낭에 추가로 넣을 수 있는 최대 무게는 `C-weight[n-1]`, 도둑이 훔친 물건의 가치는 `value[n-1]`만큼 증가, 물건 한 개 빠지고 가치 조금 는 상태에서 문제 반복
  - 안 넣을때 : 물건은 n-1개 남음(재꼇음) 배낭에 추가로 넣을 수 있는 무게는 그대로
- 각 두가지 상황에서 가치가 최대인 물건을 배낭에 넣으면 됨

```py
# 물건 n개, 지금 배낭에 넣을 수 있는 무게 C, 물건 정보 weight, value
def knapSack(C, weight, value, n):
  # 종료 조건 : 남은 물건이 없거나 배낭이 가득 찼을 때
  if (n <= 0) or (C <= 0):
    return 0

  # n번째 물건의 무게가 C보다 크면 그 물건은 넣을 수 없습니다.
  # 하지만 남은 물건 중에 C보다 작은 다른 물건이 있을지도 모릅니다.(재끼고 다음꺼)
  if weight[n - 1] > C:
    return knapSack(C, weight, value, n - 1)

  # 가방에 넣을 수 있는 물건인데, 놔두는 경우랑 먹고 가는 경우 중에 큰거
  return max(value[n - 1] + knapSack(C - weight[n - 1], weight, value, n - 1), knapSack(C, weight, value, n - 1))
```

- 지수시간, 다른 재귀 호출에서 여러번 보았던것 처럼 각 노드가 두개씩 자식 노드를 가지고 있는 재귀 호출 구조의 그림을 그릴 수 있으며 같은 하위 문제를 반복

### DP

- 물건의 최대 가격을 저장하는 방법을 찾는 것이 필요함. 일반적으로는 값을 결정하는 변수들의 차원만큼의 행렬에 대응하는 배열 사용
- 이 문제에서는 행이 물건을 나타내고 각 열이 배낭의 용량을 나타내는 행렬을 생각해볼 수 있음
- `[i][j]`의 값은 두 값 중 최대값인데 -> 이것도 놓고 가냐 갖고 가냐
  - i번째 물건을 선택하지 않았을때 최대 가격 = `dp[i-1][j]` : 걍 그 전 물건 가격 최대값을 가져온다
  - i번째 물건을 선택했을 때 최대 가격 = `dp[j - weight[i-1]] + value[i-1]` : 가치를 더하고, 물건이 들어갈 수 있는 만큼의 빈칸이 있어야하므로 저렇게

```py
def knapSack(C, weight, value, n):
  # 도둑의 최대 이익을 저장하는 배열
  # dp[i][j]는 물건이 i개가 있고 배낭의 공간이 j일 때의 값입니다.
  dp = [[0] * (C + 1) for i in range(n + 1)]

  # 바닥 조건 채우기
  # 배낭의 공간이 0일 때 도둑은 아무것도 넣을 수 없습니다.
  for i in range(0, n + 1):
    dp[i][0] = 0

  # 물건이 하나도 없을 때 도둑은 훔칠 게 없습니다.
  for j in range(0, C + 1):
    dp[0][j] = 0

  # 배열을 채워 넣습니다.
  for i in range(1, n + 1):
    for j in range(1, C + 1):
      # 물건이 배낭의 용량보다 크면 따질 필요 없이 왼쪽 셀을 복사합니다.(짜피 못넣기 때문)
      if weight[i - 1] <= j:
        x = j - weight[i - 1]
        # 안넣은 경우 넣은 경우의 max
        # 넣은 경우 꽉 찬다고 생각하고 그 전에 그 만큼만 비워있는 결과값에다가 지금 물건의 가치를 더함
        # 또는 그냥 위에꺼 가져옴
        dp[i][j] = max(value[i - 1] + dp[i - 1][x], dp[i - 1][j])
      else:
        dp[i][j] = dp[i - 1][j]


  return dp[n][C]
```

## 10. 최장 회문 부분 수열의 길이

원래 문자열 내의 글자들 중 상대적 순서를 유지하는 일부분의 수열을 부분 수열이라고 함(몇개만 뽑아 나열한 것). 하나의 문자열이 주어졌을 때 부분 수열 중 회문이 되는 가장 긴 부분 수열의 길이를 구하는 함수를 작성하기. 회문이란 정방향으로 읽거나 역방향으로 읽거나 같은 문자열

### 재귀

- X가 주어진 문자열이고 N은 X의 글자수라고 함. 문자열의 첫 글자와 마지막 글자를 비교해보고 두 글자가 같으면 양쪽 글자는 회문이 되는 부분 수열의 일부가 된다. 이 경우 앞과 뒤 두 글자를 제거한 후 나머지 문자열에서 회문이 되는 부분수열을 찾으면 전체 회문 부분 수열을 완성할 수 있음
- 이를 재귀 호출 로직으로 옮길 때는 회문에서 앞 뒤 두글자를 뺐으니 회문 부분 수열의 길이는 2만큼 증가 - 같은 경우
- 첫 글자와 끝 글자가 다르다면 문자열의 앞 N-1개 글자의 부분 수열(뒤에 있는거 하나 제낌)에서 가장 긴 회문인 부분 수열의 길이를 구하고, 또 문자열의 뒤 N-1개의 글자의 부분 수열(앞에 있는거 하나 재낌)에서 가장 긴 회문인 부분 수열의 길이를 구해 이 두 값의 최댓값을 반환하기 - 다른 경우
- 같은 경우는 회문으로 +2, 다른 경우는 앞에서 하나를 뺀거랑 뒤에서 하나를 뺀거에서 회문을 다시 찾았을 때의 최대 길이 회문
- **정답 지향적으로 생각하면 좋은 문제** 어짜피 구해야할 것은 길이니까 활자가 어떻게 생겼는지에 집중할 필요가 없음

```py
# start와 end를 가리키는 포인터
def LPS_length(string, start, end):

  # 종료조건 start >= end : 이런 경우에는 찾아볼 수가 없음
  if start > end:
    return 0

  # 가리키는게 같으면 : 가운데에 하나만 남았을때
  if start == end:
    return 1

  # 첫 글자와 끝 글자가 같을 때 - 앞뒤 하나씩 빼고 다시 돌리고 + 2
  if string[start] == string[end]:
    return LPS_length(string, start + 1, end - 1) + 2
  # 첫 글자와 끝 글자가 다를 때 - 앞, 뒤에서 하나씩 뺀걸로 재귀 돌리고 최대값
  else:
    left = LPS_length(string, start, end - 1)
    right = LPS_length(string, start + 1, end)
    return max(left, right)

string = 'BBABCBCAB'
start = 0
end = len(string) - 1
print(LPS_length(string, start, end))
```

- 지수시간 복잡도(2^n) : 재귀 거듭할수록 2개 이하의 노드가 생기는 트리. 문자열 내에 같은 글자가 한번도 반복되지 않을 때가 최악의 경우

### DP

- 상향식 풀이의 출발점은 길이가 1인 문자열의 최장 회문 부분 수열의 길이부터 찾아나가서 최종적으로 길이가 n인 문자열의 최장 회문 부분 수열의 길이까지 찾아 올라가는 것
- 이거는 길이가 1인 문자열부터 조건을 정해서 계속 올라가게끔 할 수 있으
  - 길이가 1인 문자열의 최장 회문 부분 수열 : 1
  - 길이가 2인 경우
    - 두 글자가 같으면 : 2
    - 다르면 : 1
  - 길이가 3 이상
    - 앞 뒤 글자가 같음 : 앞뒤 하나씩 빼고 + 2
    - 다름 : max(앞에 하나 뺌, 뒤에 하나 뺌)

```py
def LPS_length(string, n):
  # 빈 문자열일 때
  if (string is None) or (n == 0):
    return 0

  # 이차원 배열 - i부터 j까지의 문자열에서 최장 회문 부분 수열 길이
  dp = [[0] * n for i in range(0, n)]

  # 길이가 1인 문자열은 그 자체로 회문 = 1
  for i in range(0, n):
    dp[i][i] = 1

  # 길이가 2인 문자열의 LPSL부터 차례로 채워나갑니다.
  for k in range(2, n + 1):
    for i in range(0, n - k + 1): # 연속된 2개 픽 가능한 모든 경우의수 -> 3개 -> 4개
      # 시작점이 행이므로 테이블은 좌상단부터 대각선으로 채워짐
      # (0,1) -> (1,2) -> (2,3) ... 뭐 이런식
      # (0,2) -> (1,3) -> (2,4)
      j = i + k - 1 # 끝 글자

      # 길이가 2이며 두 글자가 모두 같으면 LPSL은 2입니다.
      if (string[i] == string[j]) and (k == 2):
        dp[i][j] = 2

      # 앞뒤 글자가 같으면 두 글자를 제외한 문자열의
      # LPS(dp[i + 1][j - 1])에 두 글자를 추가합니다.
      elif string[i] == string[j]:
        dp[i][j] = dp[i + 1][j - 1] + 2

      # 앞뒤 글자가 다른 경우 LPS가 바뀌지 않으므로
      # 앞 글자를 제외한 문자열의 LPSL과
      # 뒤 글자를 제외한 문자열의 LPSL 중 큰 값을 가져오면 됩니다.
      # 두 케이스는 일단 이전에 다 구해놨음
      else:
        a = dp[i][j - 1]
        b = dp[i + 1][j]
        dp[i][j] = max(a,b)

  return dp[0][n - 1] # 테이블 우상단의 값이 정답([시작][끝])
```
