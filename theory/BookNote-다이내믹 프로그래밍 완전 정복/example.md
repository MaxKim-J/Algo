# 책에서 나온 예제들 정리

뭔가 DP를 어캐짜냐 보다 재귀를 어캐짜냐를 배우는것같은 이번 공부...

## 1. 최소 교정 비용 문제

두 단어가 주어지고 첫번째 단어(str1)에서 수행할 수 있는 연산은 삽입, 삭제, 치환  
두 단어 간의 교정 비용은 한 단어에서 다른 단어로 바꾸는데 필요한 글자 연산의 횟수  
str1에서 str2로 바꾸는데 필요한 연산의 최소 개수를 구하는 프로그램 작성하기  

> str2를 삼아서 이전의 경우가 삽입 삭제 치환 3가지 경우로 그 다음에 온 경우를 상향식 풀이를 하면 되겠군!

### 재귀

- 같은 유형을 가진 작은 문제 : 두 글자가 같다면 양쪽 단어의 첫번째 글자에 대해서는 아무것도 하지 않아도 됨
- 삭제 : 첫 글자 삭제하고 난 후 첫 글자가 삭제된 str1 str2 사이의 최소 교정 비용
- 치환 : str1의 첫글자를 str2의 첫글자로 치환한 다음 양쪽의 첫 글자를 제외한 단어간의 최소 교정 비용
- 삽입 : str2의 첫 글자를 str1의 제일 앞에 삽입한 다음 양족 단어의 첫번째 글자를 제외한 나머지 단어의 교정 비용(삽입하고 나면 첫글자가 같아지므로)
- 연산 이후의 최소 교정 비용은 재귀 호출에 맡기기. 각 재귀 호출의 결과 중 제일 최솟값에 1을 더해 반환(어떤 연산이든 수행했던 경우에)

```py
def editDistance(str1, str2):
  #! 바닥조건
  # str1이 빈 문자열이면 str2의 모든 글자를 삽입하면 됩니다.
  if (str1 is None) or (len(str1) == 0):
    return len(str2)
  # str2가 빈 문자열일때도 마찬가지입니다.
  if (str2 is None) or (len(str2) == 0):
    return len(str1)

  # 첫번째 글자가 같을 때는 첫번째 글자를 무시하고
  # 나머지 단어 간의 최소 교정 비용을 구합니다.
  if str1[0] == str2[0]:
    return editDistance(str1[1:], str2[1:])

  # 삭제 연산 후 최소 교정 비용을 구하는 재귀 호출
  d = editDistance(str1[1:], str2)
  # 치환 연산 후 최소 교정 비용을 구하는 재귀 호출
  u = editDistance(str1[1:], str2[1:])
  # 삽입 연산 후 최소 교정 비용을 구하는 재귀 호출
  i = editDistance(str1, str2[1:])

  # 세 연산 이후 최소 교정 비용 간의 최솟값에 1을 더해서 반환합니다.(뭐든 연산을 햇기 때문에)
  # 요런거 쉽게 생각하기 힘들지도
  return min([d, u, i]) + 1
```
- O(3^n) : 자식이 계속 3개인 트리, 재귀 호출 과정에서 같은 하위 문제를 여러번 반복해서 계산

### DP

- 두 단어의 교정 비용을 구하는 과정에 필요한 모든 가능한 조합에 대해서 교정 비용을 상향식으로 구하기
- DP 테이블을 각 두 문자열의 원래 갯수에 맞춰 이차원 배열로 준비한다
- 이차원 배열의 (i,j) 값은 str1의 첫 i개의 글자와 str2의 첫 j개의 글자 사이의 최소 교정 비용의 값 => 계속 사용이 가능하다
- 행렬의 값을 모두 채우고 난 후 가장 우하단의 값이 최소 교정비용이 됨
- 첫번째 단어가 빈 문자열일 때 두 단어를 똑같이 만드려면 두 번째 단어의 모든 글자를 첫번째 단어에 삽입하거나 두번째 단어의 모든 글자를 삽입하면 되므로 글자수와 같다
- 점화식 : 두 글자가 같으면 교정비용의 차이가 없으므로 대각선 방향 왼쪽 위 셀을 그냥 가지고 온다(그 글자에 대해 추가되는 비용이 없음), 그렇지 않은 경우 치환삽입삭제 3가지 연산 중 교정비용이 가장 적은 것을 dp테이블에서 적당히 가져오고 1을 더 더해줌(연산을 했으므로) 

```
dp[i][j] = if 두 글자가 같은 경우 dp[i-1][j-1] else min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 
```

- 이렇게 문자열 다루는 DP 중에서는 저렇게 글자 수를 DP 테이블의 행과 열로 처리하는 느낌으로 풀면 좋을것 같은게 좀 있음

```py
def editDistance(str1, str2, m, n):
  dp = [[0] * (n + 1) for i in range(0, m + 1)]

  for j in range(0, n + 1):   # 제일 위 행
    dp[0][j] = j
  
  for i in range(0, m + 1):   # 제일 왼쪽 열
    dp[i][0] = i

  # dp 테이블을 전부 순회
  for i in range(1, m + 1):
    for j in range(1, n + 1):
      # 두 글자가 같다면
      if str1[i - 1] == str2[j - 1]:
        dp[i][j] = dp[i - 1][j - 1]
      # 두 글자가 다르다면
      else:
        dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1
  
  return dp[m][n]
```

- O(n^2), 공간복잡도 O(n^2)추가 : 지수시간에서 ^2시간으로...

## 2. 직사각형에서 총 경로 수 구하기

M*N개의 방으로 구성된 직사각형이 있을 때 좌상단 방에서 우하단 방까지 이동하는 **모든 경우의 수**  
방과 방 사이의 이동은 오른쪽 방향과 아래쪽 방향으로만 가능  

### 재귀

- 방 (m,n)은 다른 두 방에서 접근 가능하다 : (m-1, n), (m, n-1)
- 종료 조건은 위쪽 경계나 왼쪽 경계에 도달했을 때
- 0,0번방은 이동하는 경우가 0개
- 첫번째 행에서의 이동, 첫번째 열에서의 이동 : 쭉 이동하는 한가지 경우

```py
# 걍 그대로 구현하면 됨

def numOfPaths(m, n):
  if (m == 0) and (n == 0):   # 방 (0, 0)
    return 0
  if (m == 0) or (n == 0):    # 첫번째 행 또는 첫번째 열
    return 1
  
  # 재귀 호출
  return numOfPaths(m - 1, n) + numOfPaths(m, n - 1)
```
- O(2^n) : 자식이 계속 2개인 트리, 역시 같은 문제를 계속 반복해서 푸는 상황


### DP

- 방을 나타내는 이차원 배열 입력이 그대로 DP 테이블이 됨
- 재귀의 종료 조건으로 설명한 바 그대로 첫 행과 첫 열을 채울 수 있음

|0|1|1|1|
|-|-|-|-|
|1| | | |
|1| | | |

- 점화식 : 간단, 두 방향으로 오니까 `dp[i][j] = dp[i - 1][j] + dp[i][j-1]`
- 최종적으로 채운 배열은

|0|1|1|1|
|-|-|-|-|
|1|2|3|4|
|1|3|6|10|

```py
def numOfPaths(m, n):
  dp = [[0] * n for i in range(0, m)]

  # 바닥조건
  for i in range(1, m):
    dp[i][0] = 1
  
  for j in range(1, n):
    dp[0][j] = 1

  # 전체 DP 테이블 순회하며 채우기
  for i in range(1, m):
    for j in range(1, n):
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
  
  # 맨 우하단의 값 리턴
  return dp[m - 1][n - 1]
```