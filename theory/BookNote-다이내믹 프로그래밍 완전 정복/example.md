# 책에서 나온 예제들 정리

뭔가 DP를 어캐짜냐 보다 재귀를 어캐짜냐를 배우는것같은 이번 공부...

## 1. 최소 교정 비용 문제

두 단어가 주어지고 첫번째 단어(str1)에서 수행할 수 있는 연산은 삽입, 삭제, 치환  
두 단어 간의 교정 비용은 한 단어에서 다른 단어로 바꾸는데 필요한 글자 연산의 횟수  
str1에서 str2로 바꾸는데 필요한 연산의 최소 개수를 구하는 프로그램 작성하기  

> str2를 삼아서 이전의 경우가 삽입 삭제 치환 3가지 경우로 그 다음에 온 경우를 상향식 풀이를 하면 되겠군!

### 재귀

- 같은 유형을 가진 작은 문제 : 두 글자가 같다면 양쪽 단어의 첫번째 글자에 대해서는 아무것도 하지 않아도 됨
- 삭제 : 첫 글자 삭제하고 난 후 첫 글자가 삭제된 str1 str2 사이의 최소 교정 비용
- 치환 : str1의 첫글자를 str2의 첫글자로 치환한 다음 양쪽의 첫 글자를 제외한 단어간의 최소 교정 비용
- 삽입 : str2의 첫 글자를 str1의 제일 앞에 삽입한 다음 양족 단어의 첫번째 글자를 제외한 나머지 단어의 교정 비용(삽입하고 나면 첫글자가 같아지므로)
- 연산 이후의 최소 교정 비용은 재귀 호출에 맡기기. 각 재귀 호출의 결과 중 제일 최솟값에 1을 더해 반환(어떤 연산이든 수행했던 경우에)

```py
def editDistance(str1, str2):
  #! 바닥조건
  # str1이 빈 문자열이면 str2의 모든 글자를 삽입하면 됩니다.
  if (str1 is None) or (len(str1) == 0):
    return len(str2)
  # str2가 빈 문자열일때도 마찬가지입니다.
  if (str2 is None) or (len(str2) == 0):
    return len(str1)

  # 첫번째 글자가 같을 때는 첫번째 글자를 무시하고
  # 나머지 단어 간의 최소 교정 비용을 구합니다.
  if str1[0] == str2[0]:
    return editDistance(str1[1:], str2[1:])

  # 삭제 연산 후 최소 교정 비용을 구하는 재귀 호출
  d = editDistance(str1[1:], str2)
  # 치환 연산 후 최소 교정 비용을 구하는 재귀 호출
  u = editDistance(str1[1:], str2[1:])
  # 삽입 연산 후 최소 교정 비용을 구하는 재귀 호출
  i = editDistance(str1, str2[1:])

  # 세 연산 이후 최소 교정 비용 간의 최솟값에 1을 더해서 반환합니다.(뭐든 연산을 햇기 때문에)
  # 요런거 쉽게 생각하기 힘들지도
  return min([d, u, i]) + 1
```
- O(3^n) : 자식이 계속 3개인 트리, 재귀 호출 과정에서 같은 하위 문제를 여러번 반복해서 계산

### DP

- 두 단어의 교정 비용을 구하는 과정에 필요한 모든 가능한 조합에 대해서 교정 비용을 상향식으로 구하기
- DP 테이블을 각 두 문자열의 원래 갯수에 맞춰 이차원 배열로 준비한다
- 이차원 배열의 (i,j) 값은 str1의 첫 i개의 글자와 str2의 첫 j개의 글자 사이의 최소 교정 비용의 값 => 계속 사용이 가능하다
- 행렬의 값을 모두 채우고 난 후 가장 우하단의 값이 최소 교정비용이 됨
- 첫번째 단어가 빈 문자열일 때 두 단어를 똑같이 만드려면 두 번째 단어의 모든 글자를 첫번째 단어에 삽입하거나 두번째 단어의 모든 글자를 삽입하면 되므로 글자수와 같다
- 점화식 : 두 글자가 같으면 교정비용의 차이가 없으므로 대각선 방향 왼쪽 위 셀을 그냥 가지고 온다(그 글자에 대해 추가되는 비용이 없음), 그렇지 않은 경우 치환삽입삭제 3가지 연산 중 교정비용이 가장 적은 것을 dp테이블에서 적당히 가져오고 1을 더 더해줌(연산을 했으므로) 

```
dp[i][j] = if 두 글자가 같은 경우 dp[i-1][j-1] else min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 
```

- 이렇게 문자열 다루는 DP 중에서는 저렇게 글자 수를 DP 테이블의 행과 열로 처리하는 느낌으로 풀면 좋을것 같은게 좀 있음

```py
def editDistance(str1, str2, m, n):
  dp = [[0] * (n + 1) for i in range(0, m + 1)]

  for j in range(0, n + 1):   # 제일 위 행
    dp[0][j] = j
  
  for i in range(0, m + 1):   # 제일 왼쪽 열
    dp[i][0] = i

  # dp 테이블을 전부 순회
  for i in range(1, m + 1):
    for j in range(1, n + 1):
      # 두 글자가 같다면
      if str1[i - 1] == str2[j - 1]:
        dp[i][j] = dp[i - 1][j - 1]
      # 두 글자가 다르다면
      else:
        dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1
  
  return dp[m][n]
```

- O(n^2), 공간복잡도 O(n^2)추가 : 지수시간에서 ^2시간으로...

## 2. 직사각형에서 총 경로 수 구하기

M*N개의 방으로 구성된 직사각형이 있을 때 좌상단 방에서 우하단 방까지 이동하는 **모든 경우의 수**  
방과 방 사이의 이동은 오른쪽 방향과 아래쪽 방향으로만 가능  

### 재귀

- 방 (m,n)은 다른 두 방에서 접근 가능하다 : (m-1, n), (m, n-1)
- 종료 조건은 위쪽 경계나 왼쪽 경계에 도달했을 때
- 0,0번방은 이동하는 경우가 0개
- 첫번째 행에서의 이동, 첫번째 열에서의 이동 : 쭉 이동하는 한가지 경우

```py
# 걍 그대로 구현하면 됨

def numOfPaths(m, n):
  if (m == 0) and (n == 0):   # 방 (0, 0)
    return 0
  if (m == 0) or (n == 0):    # 첫번째 행 또는 첫번째 열
    return 1
  
  # 재귀 호출
  return numOfPaths(m - 1, n) + numOfPaths(m, n - 1)
```
- O(2^n) : 자식이 계속 2개인 트리, 역시 같은 문제를 계속 반복해서 푸는 상황


### DP

- 방을 나타내는 이차원 배열 입력이 그대로 DP 테이블이 됨
- 재귀의 종료 조건으로 설명한 바 그대로 첫 행과 첫 열을 채울 수 있음

|0|1|1|1|
|-|-|-|-|
|1| | | |
|1| | | |

- 점화식 : 간단, 두 방향으로 오니까 `dp[i][j] = dp[i - 1][j] + dp[i][j-1]`
- 최종적으로 채운 배열은

|0|1|1|1|
|-|-|-|-|
|1|2|3|4|
|1|3|6|10|

```py
def numOfPaths(m, n):
  dp = [[0] * n for i in range(0, m)]

  # 바닥조건
  for i in range(1, m):
    dp[i][0] = 1
  
  for j in range(1, n):
    dp[0][j] = 1

  # 전체 DP 테이블 순회하며 채우기
  for i in range(1, m):
    for j in range(1, n):
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
  
  # 맨 우하단의 값 리턴
  return dp[m - 1][n - 1]
```

## 3. 문자열 인터리빙 확인 문제

두 문자열 A, B가 있는데 이 문자열 내의 모든 글자의 상대적인 순서가 유지된 채 섞여서 새로운 문자열 C가 만들어지면 이때 문자열 C를 문자열 A와 문자열 B의 인터리빙이라고 부름  
xyz와 abcd가 있으면 xabyczd는 xyz와 abcd의 인터리빙  
세 개의 문자열 A, B, C가 주어졌을 때 세번째 문자열이 앞의 두 문자열의 인터리빙인지를 검사하는 함수를 작성하기  

> 이것도 약간 병합정렬식으로 재귀 돌리면 풀릴듯? DP로는 인덱스를 유지한채 a에서 온거랑 b에서 온거랑 분리해서 맞으면 계속 가고 이러면 될거같은데

## 재귀

- C의 길이가 A, B 길이 합과 같지 않다면 애초부터 아님
- C의 길이가 A와 B의 합과 같은 경우에만 다음 과정으로 넘어감
- xabyczd, xyz, abcd일때
- 반복되는 문제 캐치 : 첫번째 글자 x는 b의 첫번째 글자가 아니므로 A에서 가져온 것임이 분명함. 이때 A를 하나 날려서 이제 문자열 yz와 문자열 abcd의 인터리빙인지를 확인하는 작은 문제로 바뀜... 계속 반복
- 만약 A에서 온 것일수도 있고 B에서 온 것일수도 있을 경우 양쪽 모두를 확인해봐야함

```py
def isInterleaving(A, B, C):
  # 만약 모든 문자열이 빈 문자열인 경우
  if (len(A) == 0) and (len(B) == 0) and (len(C) == 0):
    return True
  
  # A와 B 문자열의 길이의 합이 C 문자열의 길이와 다를 때
  if len(A) + len(B) != len(C):
    return False

  caseA = False
  caseB = False

  # A의 첫글자와 C의 첫글자가 같은 경우
  if (len(A) != 0) and (A[0] == C[0]):
    caseA = isInterleaving(A[1:], B, C[1:])
  
  # B의 첫글자와 C의 첫글자가 같은 경우
  if (len(B) != 0) and (B[0] == C[0]):
    caseB = isInterleaving(A, B[1:], C[1:])

  # 가능한 케이스는 끝까지(뭔지 밝혀질때까지) 하향식으로 계산된다
  return caseA or caseB
```

- 가능한 케이스에 대해 모두 연산을 수행하고, 하향식으로 가능한 케이스가 끝까지 계산되기 때문에 당연히 반복되는 연산이 많아보인다
- O(2^n) : 2개의 자식이 반복되는 트리이므로 지수시간

## DP

- 각 단계마다 C의 부분 문자열이 A의 부분 문자열과 B의 부분 문자열의 인터리빙인지를 확인함
- 역시 이것도 각 문자 하나하나를 행과 열로 하는 DP 테이블이 필요하고, 참 거짓 여부를 채운다. 
- 행렬의 (i,j)값은 C'가 A'와 B'의 인터리비잉면 참이 됨
- (0,0)은 빈 문자열 두개를 인터리빙해도 빈 문자열이기 때문에 무조건 참으로 시작함
- 첫번째 행은 문자열 A가 빈 문자열인데 이때는 B의 부분 문자열이 C의 부분 문자열과 같으면 참(그냥 그 안에 모두 넣을 수만 있으면)
- 테이블을 채워나가는 방법은 4가지가 가능함
  - C의 현재 글자가 A의 현재 글자와 B의 현재 글자 어느쪽과도 다른 경우, 이때 셀의 값은 거짓
  - C의 현재 글자가 A의 현재 글자와 같지만 B의 현재 글자와 다를 경우, 이때 셀의 값은 바로 위 셀의 값(A의 참거짓)
  - C의 현재 글자가 B와 같지만 A와는 다른 경우 이때 셀의 값은 바로 왼쪽 셀의 값(B의 참거짓)
  - A,B,C현재 글자가 모두 같은 경우 이때 셀의 값은 위쪽 셀의 값이나 오른쪽 셀의 값 둘 중 하나가 참이면 참

```py
def isInterleaving(A, B, C):
  # A, B, C 세 문자열의 길이를 구합니다.
  M = len(A)
  N = len(B)
  lengthC = len(C)

  # A와 B 문자열의 길이의 합이 C 문자열의 길이와 다를 때
  if lengthC != M + N:
    return False

  # 인터리빙 여부를 저장하는 2차원 배열
  ilMatrix = [[True] * (N + 1) for i in range(0, M + 1)]

  # 첫번째 열을 채웁니다.(열길이 기준)
  for i in range(1, M + 1):
    if A[i - 1] != C[i - 1]: # 같지 않으면 무조건 false로 채움 => 문자열 하나만으로 인터리빙을 만들어야 하기 때문
      ilMatrix[i][0] = False
    else:
      ilMatrix[i][0] = ilMatrix[i - 1][0] # 바로 위에 꺼

  # 첫번째 행을 채웁니다. (행길이 기준)
  for j in range(1, N + 1):
    if B[j - 1] != C[j - 1]: #
      ilMatrix[0][j] = False
    else:
      ilMatrix[0][j] = ilMatrix[0][j - 1] # 바로 옆에꺼 그냥 가져옴
  
  # 나머지 셀을 채웁니다.
  for i in range(1, M + 1):
    for j in range(1, N + 1):
      currantA = A[i - 1]
      currentB = B[j - 1]
      currentC = C[i + j - 1]
      # C의 글자가 A의 글자와 같고 B의 글자와 다를 때
      if (currantA == currentC) and (currentB != currentC):
        ilMatrix[i][j] = ilMatrix[i - 1][j]
      # C의 글자가 B의 글자와 같고 A의 글자와 다를 때
      elif (currantA != currentC) and (currentB == currentC):
        ilMatrix[i][j] = ilMatrix[i][j - 1]
      # A, B, C 글자 모두가 같을 때
      elif (currantA == currentC) and (currentB == currentC):
        ilMatrix[i][j] = ilMatrix[i - 1][j] or ilMatrix[i][j - 1]
      else:
        ilMatrix[i][j] = False

  # 완성된 행렬을 출력합니다.
  for i in range(0, M + 1):
    for j in range(0, N + 1):
      print('%s' % 'T ' if ilMatrix[i][j] else 'F ', end = '')
    print()

  return ilMatrix[M][N]  

```

- 불리언을 DP 테이블에 넣어 연관성있게 다른 칸의 값도 나오는게 좀 유형이 신기한 문제였던 것 같음
- O(n^2)로 반복되는 연산을 메모이제이션하기 때문에 시간이 줄어든다.

## 4. 부분집합의 합 구하기

0과 양의 정수로 이루어진 집합이 있고 또 다른 양의 정수 X가 있을 때 주어진 집합의 부분집합 중에 원소의 합이 X인 부분집합이 존재하는지 검사하는 함수 작성하기

### 재귀

- 두 가지 가능성
  - 부분집합에 X를 포함한다면 집합의 나머지에서 합이 X-P가 되는 부분집합을 찾아야 함
  - 부분집합에 X를 포함하지 않는다면 집합의 나머지에서 합이 X가 되는 부분집합을 찾아야 함
- 재귀 호출의 종료 조건은 X가 0이 되었는지(X를 줄여나가면서 재귀를 돌림), 혹은 집합 내의 원소를 모두 사용했는데 X가 0이 아닐때.
- 특수한 경우로는 원소의 값이 X보다 큰 경우인데, 이런 원소는 재귀호출 없이 부분집합에 포함하지 않아도 됨(그거 하나 넣으면 이미 넘쳐버림)

```py
def isSubsetSum(arr, n, X):
  # 종료 조건 1 : X가 0이면 성공 종료 조건입니다.
  if X == 0:
    return True

  # 종료 조건 2 : X가 0이 아니고 남은 원소가 없다면 실패 종료 조건입니다.
  if n == 0:
    return False
  
  # X보다 큰 원소는 무시해도 좋습니다.(안 넣는다)
  if arr[0] > X:
    return isSubsetSum(arr[1:], n - 1, X)

  # 맨 앞에꺼 가지고 어떻게 할지 정하는데
  # 부분집합에 원소를 포함시키지 않는 경우와 
  # 원소를 포함시키는 경우 각각에 대해 재귀 호출합니다. => 선형 + 재귀 아이디어로 부분합 구하기 넣고갈거냐 빼고갈거냐
  return isSubsetSum(arr[1:], n - 1, X) or isSubsetSum(arr[1:], n - 1, X - arr[0])    
```

- 명백하게 반복계산이 이루어지고 있음 - 경우의 수 마다 어떤 특정 수 X를 반복해서 넣으며 X를 줄이거나 하기 때문에 : O(2^n)

### DP

- DP 테이블은 이차원 배열로, 행은 합 열은 부분집합의 숫자들
- `dp[i][j]`는 집합의 첫 (i+1)개의 원소로 구성된 집합에 대하여 합이 0 <= j <= X인 부분집합에 대한 **참/거짓** 값
- 첫번째 열은 모두 참임 공집합인 부분집합의 원소의 합은 언제나 0이기 때문
- 첫번째 행은 행의 첫번째 숫자인거만 참

|수\합|0|1|2|3|4|5|6|
|-|-|-|-|-|-|-|-|
|3|T|F|F|T|F|F|F|
|2|T| | | | | | |
|7|T| | | | | | |
|1|T| | | | | | |

- 나머지 행을 채워나가는데, 이때 채워나가는 과정에서 각 행에 해당되는 값을 v라고 하면 처음 v칸 만큼은 바로 위쪽의 행을 복사함. 부분집합에 그 숫자 하나 더 추가되었다고 해서 더 작은 합을 만드는 데에는 영향을 주지 않기 때문
- 나머지 셀들은
  - (i-1, j)가 T면 (i,j)도 T : 부분집합에 이미 V를 포함하지 않고도 합을 만들 수 잇음
  - 그 밖의 경우는 (i-1, j-v) 셀의 값을 (i,j)로 복사 : (이전 행, 만들어야되는 숫자 - 부분집합에 새롭게 들어온 숫자 = 새로운 숫자가 없을때 해당 합 만드는게 가능했는지, 새로운 숫자 더했을때 합만큼 딱 구해야 하는 전체 합수가 늘어났는지)
- 세번째 행같은 경우 합 6을 만드는데 7은 아무런 소용이 없으므로 바로 위 행을 그대로 복사해서 만들면 됨
- 우하단 셀의 값이 답


|수\합|0|1|2|3|4|5|6|
|-|-|-|-|-|-|-|-|
|3|T|F|F|T|F|F|F|
|2|T|F|T|T|F|T|F|
|7|T|F|T|T|F|T|F|
|1|T|T|T|T|T|T|T|

```py
def isSubsetSum(arr, n, X):
  subsum = [[False] * (X + 1) for i in range(0, n)]

  # 첫번째 열은 항상 참
  for i in range(0, n):
    subsum[i][0] = True
  
  # 첫번째 행은 j가 0 또는 arr[0]인 경우만 참
  for j in range(1, X + 1):
    if arr[0] == j:
      subsum[0][j] = True
    else:
      subsum[0][j] = False

  # 나머지 셀을 채웁니다.
  for i in range(1, n):
    v = arr[i]
    for j in range(1, X + 1):
      if j < v:
        subsum[i][j] = subsum[i - 1][j] # 영향 주지 않으므로 그대로 가져옴
      elif subsum[i - 1][j]:
        subsum[i][j] = True # 이미 포함하지 않고도 합을 만들 수 있으므로 T를 그대로 가져옴
      else:
        subsum[i][j] = subsum[i - 1][j - v] 
        # 만들려는 합수에서 추가되는 수만큼 빼고 추가되는 수가 없다고 가정했을 때 이미 합수를 만들수 있었느냐를 타진
  
  # 완성된 행렬을 출력해봅니다.
  for i in range(0, n):
    for j in range(0, X + 1):
      print('%s' % ('T ' if subsum[i][j] else 'F '), end = '')
    print()

  return subsum[n - 1][X]
```

- 얼핏 보면 for문을 대충 두겹 돌리니 O(n^2)같지만 X는 상수이고 입력 집합의 길이와 무관한 값이므로 O(n)이 됨 진짜 많이 줄었네