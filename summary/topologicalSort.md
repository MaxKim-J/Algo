# 위상 정렬
2020.02.20

## 정의
사이클이 없는 유향 그래프 `G=(V,E)`에서 V의 모든 정점을 정렬하되  
간선 (i,j)가 존재하면 정렬 결과에서 정점 i는 반드시 정점 j보다 앞에 위치해야 함  
만약 그래프에 사이클이 있다면 이 성질을 결코 만족될 수 없으므로 위상정렬은 할 수 없음(가장 먼저인 정점 i가 가장 뒤인 정점 j의 뒤에 있으므로)  

## 알고리즘 1 - 진입점 없는 정점 선택

### 동작
```shell
topologicalSort(G, v) {
    # 진입 간선이 없는 정점 u를 선택
    for i <- 1 to n {
        A[i] <- u
    # 정점 u와 u의 진출 간선들을 모두 제거
    }
}
```
진입 간선이 없는 정점을 선택하고, 간선들을 모두 제거하면 다른 어떤 정점이  
진입 간선이 없는 정점이 될 것이고, 거기서 다시 u와 u의 간선들을 제거하면  
한번에 하나씩 정점이 사라지고, 이는 곧 새로운 배열에 위상정렬 된다  
진입 간선 없는 정점들이 여러개 있을 때는 아무거나 먼저 선택한다(위상정렬의 답은 여러개가 될 수 있다)  

### 수행시간
for루프는 n번(정점의 개수만큼) 반복됨  
매 반복 때마다 1개의 정점이 선택되고, 해당 정점에 연결된 간선들이 모두 제거  
각 간선은 단 한번씩만 취급됨 따라서 O(V+E)  
정점이 많을수록, 간선이 많을수록 수행시간은 선형적으로 증가  

## 알고리즘 2 - DFS 이용하기

### 동작
```shell
topologicalSort2(G){
    # 방문 배열 안에서 초기화
    for v in V:
        visited[v] = NO;

    # 정점의 순서는 무관하게
    # 방문한 노드가 아니라면 dfs를 수행
    for v in V:
        if (visited[v] = NO):
            DFS-TS(v)
}

DFS-TS(v){
    # 방문 시작한 노드를 방문했다고 표시
    visited[v] = YES;

    # 방문 시작한 노드에 접한 다른 노드들 모두 탐색
    for x in 정점 v에 접한 다른 정점:
        if (visited[v] = NO):
            DFS-TS(v)

    # 리스트 r의 맨앞에 정점 v를 삽입(완료된 정점)
    # 인접한 모든 정점을 방문한 뒤 할일이 없는 경우에 리스트에 추가됨
    [].insert(0, v)
}
```
최종적으로 연결리스트 r에는 그림에서 표시된 완료 순서의 역순으로  
정점들이 저장되어 있고, 이 순서가 위상 정렬 순서  