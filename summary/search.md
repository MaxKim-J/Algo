# 탐색
2020.02.11

## 순차탐색
배열의 가장 좌측부터 시작하여 찾으려는 값과 하나씩 배열의 각 요소와 비교  
찾는 값을 발견하면 배열의 해당 인덱스를 반환함  
찾으려는 값이 없다면 -1을 반환함  

### 구현
```python
# 많이 보았을 것
def linearSearch(arr, key):
  for i in range(len(arr)):
    if key == arr[i]:
      return i
  return -1
```

### 시간복잡도
리스트의 각 요소를 하나씩 키와 비교함 => 모두 훑으므로 O(n)  
리스트 요소의 수가 커지면 커질수록 선형 검색 시간은 증가, 큰 리스트에서는 비효율적


## 이진탐색
**정렬**된 리스트의 중간부터 비교해나가는 접근법  
리스트를 반으로 나눠 검색해나감
>**세가지 경우의 수** 
키가 리스트의 중간 요소보다 작을 경우, 리스트의 중간 이전까지만 탐색
키가 리스트의 중간 요소와 일치할 경우, 검색은 끝
만약 키가 리스트의 중간 요소보다 클 경우, 리스트의 중간 이후만 탐색하면 됨

### 구현
```python
def binarySearch(arr, key):
  start, end = 0, len(arr)-1
  while end >= start:
    mid = (start+end)//2
    if key<arr[mid]:
      end = mid - 1
    elif key == arr[mid]:
      return mid
    else:
      start = mid+1
  return -1
```
### 시간복잡도
첫 시행 이후 반 버려지니 => n/2  
그 후 또 반 버려지니 => n/4  
그후 또 => n/8
k번 시행하면? => (1/2)^k*n개가 남음  
루프가 끝나는 시점에는 남은 자료가 1개이므로  
(1/2)^kn가 대략 1이라고 가정한 후 풀면 => O(log2n)  
순차탐색보다 빠르다!
