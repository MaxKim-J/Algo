# 다익스트라

하나의 정점에서 다른 모든 정점간의 각각 가장 짧은 거리를 구하는 문제를 푸는데 사용하는 알고리즘 => 단일 출발 최단 경로 문제

## 로직

- 첫 정점을 기준으로 연결되어 있는 정점들을 추가해 가며, 최단거리를 갱신
- 너비우선탐색과 유사 : 첫 정점부터 각 노드간의 거리를 저장하는 배열을 만든 후, 첫 정점의 인접 노드간의 거리부터 먼저 계산하면서 첫 정점부터 해당 노드간의 가장 짧은 거리를 해당 배열에 업데이트
- 우선순위큐를 사용(min-heap) : 현재 가장 짧은 거리를 가진 노드 정보를 먼저 꺼내게 됨
- `왜 가장 짧은거부터 순회하지?` : 우선순위 큐는 정점까지의 최단거리를 기준으로 정점을 배열함으로써 아직 방문하지 않은 정점 중 시작점으로부터 가장 가까운 점을 찾는 것을 간단하게 해줌

## 특징

- 역시 어떤 최단경로가 중간 노드들의 최단경로를 포함한다는 느낌은 그대로 가져감
- 일종의 DP같은 성격 : 최단 거리는 여러개의 최단 거리로 이루어져 있다. 하나의 최단 거리를 구할때 그 이전까지 구했던 최단거리 정보를 그대로 사용한다(중복된 계산 없애기)
- 딱히 visited가 없어도 모든 간선을 한번만 순회한다 : 최단 경로 발견 이후에 거리를 더는 갱신하지 않기 때문
- BFS와 유사한 형태로 시작점에서 가까운 순서로 정점을 방문한다
- `음수 간선이 존재하는 그래프의 경우 사용할 수 없다` : 왜?

### 흐름

1. 첫 정점을 기준으로 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 저장(첫 정점의 거리는 0, 나머지는 무한대로 저장)
2. 우선순위 큐에서 노드를 꺼냄

- 처음에는 첫 정점만 저장되어 있어 첫 정점이 꺼내지고
- 첫 정점에 인접한 노드들 각각에 대해, 첫 정점에서 각 노드로 가는 거리와 현재 배열에 저장되어있는 첫 정점에서 각 정점까지의 거리를 비교

3. 배열에 저장되어 있는 거리보다, 첫 정점에서 해당 노드로 가는 거리가 더 짧을 경우 배열에 해당 노드의 거리를 업데이트
4. 배열에 해당 노드의 거리가 업데이트되었으면 우선순위 큐에 넣는다

- 결과적으로 BFS와 유사하게 첫 정점에 인접한 노드들을 순차적으로 방문하게 됨
- 만약 배열에 기록된 현재까지 발견된 가장 짧은 거리보다, 더 긴 거리를 가진 경우에는 해당 노드와 인접한 노드와의 거리계산을 하지 않음

5. 우선순위 큐에서 꺼낼 노드가 없을 때까지 반복

## 시간 복잡도

- 크게 두가지 과정

  - 노드마다 인접한 간선들을 모두 검사
  - 우선순위 큐에 노드/거리 정보를 넣고 삭제

- 각 노드는 최대 한번씩 방문하므로, 그래프의 모든 간선은 최대 한번씩 검사 => O(E)
- 최악 시나리오 : 우선순위 큐에 가장 많은 노드, 거리 정보가 들어가는 시나리오는 그래프의 모든 간선이 검사될때마다 배열의 최단거리가 갱신되고, 우선순위 큐에 추가되는 것
- 이때 추가는 각 간선마다 최대 한번 일어날 수 있으므로 최대 O(E), O(E)개의 노드/거리 정보에 대해 우선순위 큐를 유지하는 작업(heapify)는 O(logE)가 걸림
- 따라서 O(ElogE) => 간선의 개수에 달려잇다. 또한 엣지는 정점의 제곱이 최악이기 때문에 대충(n^2logn)
- 힙의 시간 복잡도: 트리의 높이를 h라고 할때, n개의 노드를 가지는 heap에 데이터 삽입 혹은 삭제시, 최악의 경우 root노드에서 leaf까지 비교해야 하므로 이진트리에서 h는 log2n에 가까우므로 시간복잡도는 O(logn)
