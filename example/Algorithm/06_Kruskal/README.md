# 최소 신장 트리

## 신장 트리(스패닝 트리)

- 그래프에서 최소한의 간선만 사용하여 연결해놓은 트리
- 그래프에서 일부 간선을 선택해서 만든 트리
- n개의 정점을 가지는 그래프의 최소 간선의 개수가 n-1개이고, n-1개의 간선으로 연결되어있으면 필연적으로 트리 형태(사이클이 없는 그래프)가 되고 이게 최소신장트리
- 하나의 그래프에는 많은 신장 트리가 존재할 수 있다
- 모든 정점들이 연결되어있어야 하고 사이클을 포함해서는 안된다
- 회사 내의 모든 전화기를 가장 적은 수의 케이블을 사용하여 연결하고자 하는 경우

## 최소 신장 트리

신장 트리 중에서 사용된 간선들의 가중치 합이 최소인 트리

- 간선 가중치를 고려하여 여러 개의 스패닝 트리 중에 최소 비용의 스패닝 트리를 선택한다
- 즉 네트워크에 있는 모든 정점들을 가장 적은 수의 간선(신장트리)과 비용(최소신장트리)으로 연결하게 된다

# 크루스칼 알고리즘

최소 신장 트리를 구하는 알고리즘

## 특징

- 그리디 : 눈 앞의 최소비용 선택
- 유니언 파인드 : 두 정점의 최상위 정점을 확인할때 사용. 사이클 생성 여부를 확인한다. 추가하고자 하는 간선의 양끝 정점이 같은 집합에 속해 있으면 사이클이 형성된다. 그럴때 간선을 추가하면 안됨
- union-by-rank : 각 트리의 높이를 기억해뒀다가 두 트리의 높이가 다르면 높이가 작은 트리를 큰 트리에 붙임. 유니언의 순서에 따라 최악의 경우 연결리스트처럼 선형으로 연결된 느낌이 될 수 있음. 트리의 높이를 최대한 유지하면서 신장트리를 합치는 방법(일종의 균형트리) => 각 유니언의 높이를 따로 기록할 자료구조가 필요
- 간선을 순회하고 접하고 있는 두 정점을 평가
- 각각의 노드들이 유니언파인드 처럼 처음에 단일한 집합이었다가 간선을 평가하면서 집합이 하나씩 늘어나게 된다

## 흐름

- 모든 정점을 독립적인 집합으로 만든다
- 모든 간선의 비용을 기준으로 정렬하고, 비용이 작은 간선부터 양끝의 두 정점을 비교한다 => 비용이 작은 간선부터 고려함으로써 정점들을 잇는데 최소한의 비용만 사용하게 만든다
- 두 정점의 최상위 정점을 확인하고, 서로 다를 경우 두 정점을 연결한다(사이클이 생기지 않게)

## 시간 복잡도

O(ElogE)

- 간선들을 비용 기준으로 정렬하는 시간에 좌우된다. 일반적으로 가장 빠른 정렬이 O(nlogn)이므로 얘도 O(ElogE)
- 두 정점의 최상위 정점을 확인하고 연결하는 것은 집합을 타고넘기 때문에, 연결리스트처럼 트리가 일자인 최악의 경우 대충 O(n)정도 걸리긴 하는데, union by rank로 상수값에 가깝게 만들 수 있다
