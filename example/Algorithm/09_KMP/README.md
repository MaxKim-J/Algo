# KMP 문자열 검색 알고리즘

어려운걹...?

## 특징

- 일일히 하는 가장 단순한 방법의 문자열 검색은 탐색의 대상이 되는 문자열에서 매칭이 되는 패턴을 계속해서 검색해야 한다. 이 과정의 시간 복잡도는 탐색의 대상이 되는 문자열 N, 패턴의 길이를 M이라고 할때 O(NM)이 걸린다.
- KMP를 사용하면 O(N+M)에 문자열 검색을 할 수 있다.
- KMP 알고리즘에서 사용하는 정보들
  - 접두사 : 앞에서부터 헤아리는 문자열 (banana일때 b, ba, ban, bana...)
  - 접미사 : 뒤에서부터 헤아리는 문자열 (banana일때 a, an, ana, nana...)
  - LPS배열 : 주어진 문자열의 0~i까지의 모든 부분 중에서 prefix==suffix가 될 수 있는 부분 문자열 중 가장 긴 것의 길이
  - 문자열 ABAABAB에서
    | i | 부분 문자열 | pi[i] | 비고 |
    | -- | ---------- | ----- | - |
    |0|A|0| 없음|
    |1|AB|0|없음|
    |2|ABA|1|앞과 뒤의 A같음|
    |3|ABAA|1|앞과 뒤의 A같음|
    |4|ABAAB|2|앞과 뒤의 AB같음|
    |5|ABAABA|3|앞과 뒤의 ABA같음|
    |6|ABAABAB|2|앞과 뒤의 AB같음|
- 단순 비교와는 다르게 KMP 알고리즘은 **부분만 일치해도** 그 사실을 바탕으로 전체 일치하는 패턴을 찾아낸다. 단순 비교는 하나만 불일치해도 버린다.
- 틀렸다는 사실이 아니라 조금이라도 일치했었다는 정보에 주목하고 미리 전처리해둔 pi배열을 이용해서 많은 중간 시도를 껑충 건너뛸 수 있게 한다.

## 흐름

1. LPS 배열을 만든다
2. KMP를 돌린다
3. 처음에 두 인덱스(idx, pidx)를 0부터 시작해서 비교한다. 
4. 패턴과 word의 글자가 같을 경우인데 pidx가 아직 패턴의 끝 인덱스에 도달하지 않았을 때는 두 인덱스를 모두 올린다.
5. 패턴과 word의 글자가 같은 경우이고 pidx가 패턴의 끝 인덱스까지 왔을때는 일치 패턴을 발견한 것이므로, LPS의 마지막 값만큼 값을 밀어서 pidx를 조정한 후 그 값부터 다시 비교를 시작한다. 결과도 기록한다.
5. 패턴과 word의 글자가 같지 않을 경우는 불일치 패턴을 발견한 것이므로, 접두어만큼 뒤로 비교하는 문자열을 밀어야 한다. 따라서 LPS table을 이용하여 pidx를 조정하는데, 이때 pidx-1까지는 word와 pattern이 모두 일치했으므로 pidx-1의 LPS 값을 가져와 그 인덱스 부터 패턴 비교를 다시 시작한다. pidx-1의 값을 가져왔는데도 word와 pattern이 불일치할 경우 일치할 때까지 pidx를 줄여낸다. 하나도 일치하지 않을 경우 pidx를 0으로 만든다.

### 어떻게 돌아가나

걍 흐름만 쓰면 도저히 이해가 안되서 알고리즘이 어떻게 돌아가는지를 그냥 쓰겠음

![흐름](https://t1.daumcdn.net/cfile/tistory/99FB64425C7E699F06)

ABABAABAABAA에서 ABAABA찾기  
table = [0,0,1,1,2,3]

1. idx = 0, pidx = 0 => word[idx]와 pattern[pidx]가 같은데 pidx가 패턴의 끝이 아니므로 pidx를 1로 만들어줌
2. idx = 1, pidx = 1 => word[idx]와 pattern[pidx]가 같은데 pidx가 패턴의 끝이 아니므로 pidx를 2로 만들어줌
3. idx = 2, pidx = 2 => word[idx]와 pattern[pidx]가 같은데 pidx가 패턴의 끝이 아니므로 pidx를 3 만들어줌
4. idx = 3, pidx = 3 => word[idx]와 pattern[pidx]가 같지 않은데 pidx가 0 이상이므로 table을 통해 pidx를 조정, table[2] = 1을 새로운 pidx로 설정함(처음 시작점이었던 A까지를 재활용, 접미어 A랑 맞춰줌). idx = 3, pidx = 1 이면 word[idx]와 pattern[pidx]가 일치하지만 또한 pidx가 패턴의 끝은 아니므로 pidx를 2로 만들어줌. 불일치 패턴을 처음으로 발견했고, pidx를 조정해서 다음 시작점을 찾았음
5. idx = 4, pidx = 2 => word[idx]와 pattern[pidx]가 같은데 pidx가 패턴의 끝이 아니므로 pidx를 3으로 만들어줌
6. idx = 5, pidx = 3 => word[idx]와 pattern[pidx]가 같은데 pidx가 패턴의 끝이 아니므로 pidx를 4로 만들어줌
7. idx = 6, pidx = 4 => word[idx]와 pattern[pidx]가 같은데 pidx가 패턴의 끝이 아니므로 pidx를 5로 만들어줌
8. idx = 7, pidx = 5 => word[idx]와 pattern[pidx]가 같은데 pidx가 패턴의 끝이므로 패턴을 하나 발견한 것임(1). 시작점을 결과 배열에 저장하고, pidx를 패턴을 찾았을 때의 값인 마지막 값, pidx[5]인 3으로 만들어줌. 일치된 패턴을 하나 찾았기 때문에 다음 패턴매칭은 3개를 띄워서 시작 가능하다는 뜻임
9. idx = 8, pidx = 3 => word[idx]와 pattern[pidx]가 같은데 pidx가 패턴의 끝이 아니므로 pidx를 4로 만들어줌
10. idx = 9, pidx = 4 => word[idx]와 pattern[pidx]가 같은데 pidx가 패턴의 끝이 아니므로 pidx를 5로 만들어줌
11. idx = 10, pidx = 5 => word[idx]와 pattern[pidx]가 같은데 pidx가 패턴의 끝이므로 패턴을 하나 발견할 것임(2). 시작점을 결과 배열에 저장하고, pidx를 패턴을 찾았을 때의 마지막 값, pidx[5]인 3으로 만들어줌. 일치된 패턴을 하나 찾았기 때문에 다음 패턴매칭은 3개를 띄워서 시작이 가능함
12. idx = 11, pidx = 3 => word[idx]와 pattern[pidx]가 같은데 pidx가 패턴의 끝이 아니므로 pidx를 4로 만들어줌
13. 비교 당하는 문자열의 길이 끝. 알고리즘 종료. 일치되는 패턴은 2개 찾았음

살펴보면, 불일치 패턴을 발견하면 접두어-접미어 일치 값을 이용하여 그 값만큼 뒤로 보내서 비교를 다시 시작하고, 일치하는 패턴을 발견했을 때는 접두어-접미어 일치 값의 마지막 값을 이용하여 그 값만큼 또 뒤로 보내서 비교를 다시 시작하고 있다.  

불일치, 일치 패턴을 어떻게 발견하느냐에 따라 패턴의 비교 시작 지점을 계속 조정하여 비교하는 알고리즘이다.

## 시간 복잡도

- 불일치 패턴, 일치 패턴을 찾았을 때 탐색 시작점에서 tidx만큼 이동한다. 따라서 O(N+M)정도라고 생각할 수 있다.
- 비교 당하는 문자열을 중심으로 순회를 하기 때문에 탐색하는 문자열의 길이에 비래한다. 보통 O(N)이 된다.