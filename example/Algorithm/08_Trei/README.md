# 트라이 자료구조

## 특징

- Redix Tree, Prefix Tree라고도 부른다.
- 한 단어의 접두어를 모두 저장하는 트리를 만드는 문자열 자료구조이다.
- 트라이에서는 단어들이 서로 포함관계에 있다는 것을 알려준다
- class node를 만들어서 하는게 나아보인다. 하나의 인스턴스에 들어가야할 자료가 좀 많은 편이라
- 여러개 단어의 공통 접두어 부분을 검출해낼 수 있고 공통 접두어를 가지는 단어가 총 몇개인지도 약간 변형해서 노드에 기록할 수 있을 것이다. (isEnd 뿐 아니라)

## 흐름

1. 노드를 만든다
2. 삽입 : 문자열의 각 문자에 대해 헤드부터 탐색 시작하고 각 문자의 char을 모두 순회한다. 문자가 노드에 있으면 그 노드로 들어가고 없으면 새로운 노드를 현재 노드의 자식으로 넣어준다.
3. 검색 : 찾으려는 문자열(혹은 쿼리)을 인자로 받아서 문자열의 문자를 모두 순회한다. 역시 루트에서부터 차례대로 아래로 내려와서 문자가 있으면 아래로 내려가고 없으면 걔는 없는거니까 false를 리턴한다. 문자열을 다 순회할때까지 false를 리턴하지 않았다면 isEnd를 확인해서 노드 위치를 리턴한다.


## 시간 복잡도

- 문자열의 길이 N에 대해 삽입과 검색을 모두 O(N)에 해낸다. 
- 정규표현식처럼 하나의 노드를 탐색해도 여러 개의 문자열을 매칭시킬 수 있기 때문에 그 점에서 탐색 효율이 좋다. 시간은 O(N)이 걸려도 결과를 여러개 도출시킬 수 있다
- 대신에 메모리를 꽤 쓰게된다. 발견된 문자의 개수만큼 공간을 차지한다. 